{"pages":[{"title":"Gallery","text":"","link":"/album/index.html"}],"posts":[{"title":"二叉树中的最大路径和","text":"题目路径被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中至多出现一次。该路径至少包含一个节点，且不一定经过根节点。 路径和 是路径中各节点值的总和。 给你一个二叉树的根节点 root ，返回其 最大路径和 。 输入：root = [-10,9,20,null,null,15,7]输出：42解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42 递归林小鹿 路径 在这道题目中，路径是指从树中某个节点开始，沿着树中的边走，走到某个节点为止，路过的所有节点的集合。路径的权值和是指路径中所有节点的权值的总和。 对于一棵树，我们可以将其划分为很多的子树，如下图所示，虚线矩形围起来的子树。我们把这颗子树的蓝色节点称为该子树最高节点。用最高节点可以将整条路径分为两部分：从该节点向左子树延伸的路径，和从该节点向右子树延伸的部分。 递归遍历整棵树，递归时维护从每个子树从最高节点开始往下延伸的最大路径和。 对于每个子树的最高节点，递归计算完左右子树后，我们将左右子树维护的两条最大路径，和该点拼接起来，就可以得到以这个点为最高节点子树的最大路径。（这条路径一定是：左子树路径-&gt;最高节点-&gt;右子树路径）然后维护从这个点往下延伸的最大路径：从左右子树的路径中选择权值大的一条延伸即可。（只能从左右子树之间选一条路径）最后整颗树的最大路径和为: 根节点值+左子树最大路径和+右子树最大路径和，即left_max + right_max + root-&gt;val 注意 如果某条路径之和小于0，那么我们选择不走该条路径，因此其路径之和应和0之间取最大值。 时间复杂度分析: 每个节点仅会遍历一次，所以时间复杂度是 O(n)。 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: int res = INT_MIN; int maxPathSum(TreeNode* root) { dfs(root); return res; } int dfs(TreeNode* root){ if(!root) return 0; int left = max(0, dfs(root-&gt;left)), right = max(0, dfs(root-&gt;right)); res = max(res, root-&gt;val + left + right); return root-&gt;val + max(left, right); }}; DFS-非自顶而下作者：eh-xing-qing总结得实在好 非自顶而下 这类题目一般解题思路如下：设计一个辅助函数maxpath，调用自身求出以一个节点为根节点的左侧最长路径left和右侧最长路径right，那么经过该节点的最长路径就是left+right接着只需要从根节点开始dfs，不断比较更新全局变量即可 12345678910int res=0;int maxPath(TreeNode *root) //以root为路径起始点的最长路径{ if (!root) return 0; int left=maxPath(root-&gt;left); int right=maxPath(root-&gt;right); res = max(res, left + right + root-&gt;val); //更新全局变量 return max(left, right); //返回左右路径较长者} 这类题型DFS注意点 left,right代表的含义要根据题目所求设置，比如最长路径、最大路径和等等 全局变量res的初值设置是0还是INT_MIN要看题目节点是否存在负值,如果存在就用INT_MIN，否则就是0 注意两点之间路径为1，因此一个点是不能构成路径的 1234567891011121314151617181920class Solution{public: int res = INT_MIN; //注意节点值可能为负数，因此要设置为最小值 int maxPathSum(TreeNode *root) { maxPath(root); return res; } int maxPath(TreeNode *root) //以root为路径起始点的最长路径 { if (!root) return 0; int left = max(maxPath(root-&gt;left), 0); int right = max(maxPath(root-&gt;right), 0); res = max(res, left + right + root-&gt;val); //比较当前最大路径和与左右子树最长路径加上根节点值的较大值，更新全局变量 return max(left + root-&gt;val, right + root-&gt;val); //返回左右子树较长的路径加上根节点值 }};","link":"/2022/07/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"},{"title":"二叉树的下一个结点","text":"题目给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 分析二叉树的下一个节点，一共有以下情况： 二叉树为空，则返回空； 节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点； 节点不是根节点。如果该节点是其父节点的左孩子，则返回父节点；否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果。 12345678910111213141516171819202122232425262728/*struct TreeLinkNode { int val; struct TreeLinkNode *left; struct TreeLinkNode *right; struct TreeLinkNode *next; //父节点 TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) { }};*/class Solution {public: TreeLinkNode* GetNext(TreeLinkNode* pNode) { if(pNode-&gt;right) { //如果有右子树，则找右子树的最左节点 TreeLinkNode *p = pNode-&gt;right; while(p-&gt;left) p = p-&gt;left; return p; } TreeLinkNode *p = pNode; while(p-&gt;next) { //没右子树，则找第一个当前节点是父节点左孩子的节点 if(p-&gt;next-&gt;left == p) return p-&gt;next; p = p-&gt;next; } return nullptr; //退到了根节点仍没找到，则返回null }}; 复习 前序遍历：F, B, A, D, C, E, G, I, H中序遍历：A, B, C, D, E, F, G, H, I后序遍历：A, C, E, D, B, H, I, G, F层次遍历：F, B, G, A, D, I, C, E, H","link":"/2022/07/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9/"},{"title":"反转链表","text":"题目给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 输入：head = [1,2,3,4,5]输出：[5,4,3,2,1] 递归路漫漫我不畏 使用递归函数，一直递归到链表的最后一个结点，该结点就是反转后的头结点，记作 cur 此后，每次函数在返回的过程中，让当前结点的下一个结点的 next 指针指向当前节点 同时让当前结点的 next 指针指向 NULL ，从而实现从链表尾部开始的局部反转 当递归函数全部出栈后，链表反转完成 123456789101112131415class Solution{public: ListNode *reverseList(ListNode *head) { if (head == NULL || head-&gt;next == NULL) { return head; } ListNode *cur = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return cur; }}; 简单的双指针 定义双指针：pre 和 cur 局部反转：pre-&gt;next=cur pre 和 cur 同时右移一个位置 循环上述过程，直至 pre 到达链表尾部 12345678910111213141516class Solution{public: ListNode *reverseList(ListNode *head) { ListNode *cur = NULL, *pre = head; while (pre != NULL) { ListNode *tmp = pre-&gt;next; pre-&gt;next = cur; cur = pre; pre = tmp; } return cur; }}; 较复杂的双指针 定义指针 cur ，初始化为 head 局部反转：head-&gt;next 的 next 指向 cur cur 和 head-&gt;next 同时右移一个位置 循环上述过程，直至 cur 到达链表尾部 1234567891011121314151617181920class Solution{public: ListNode *reverseList(ListNode *head) { if (head == NULL) { return NULL; } ListNode *cur = head; while (head-&gt;next != NULL) { ListNode *t = head-&gt;next-&gt;next; head-&gt;next-&gt;next = cur; cur = head-&gt;next; head-&gt;next = t; } return cur; }};","link":"/2022/07/11/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"title":"数组中的第K个最大元素","text":"题目给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 输入：[3,2,3,1,2,4,5,5,6] 和 k = 4输出：4 暴力求解1234567891011121314#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution {public: int findKthLargest(vector&lt;int&gt; &amp;nums, int k) { int size = nums.size(); sort(begin(nums), end(nums)); return nums[size - k]; }}; 大顶堆调用priority_queue 12345678910111213class Solution{public: int findKthLargest(vector&lt;int&gt; &amp;nums, int k) { priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; maxHeap; for (int x : nums) maxHeap.push(x); for (int _ = 0; _ &lt; k - 1; _++) maxHeap.pop(); return maxHeap.top(); }}; NB solution 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution{public: void shiftDown(vector&lt;int&gt; &amp;nums, int i, int len) { int root = i; while (root &lt; len) { int tmp = root; int left = 2 * root + 1, right = 2 * root + 2; if (left &lt; len &amp;&amp; nums[root] &lt; nums[left]) { root = left; } if (right &lt; len &amp;&amp; nums[root] &lt; nums[right]) { root = right; } if (root == tmp) { break; } swap(nums[tmp], nums[root]); } } void buildHeap(vector&lt;int&gt; &amp;nums) { int n = nums.size(); for (int i = n / 2 - 1; i &gt;= 0; i--) { shiftDown(nums, i, n); } } int findKthLargest(vector&lt;int&gt; &amp;nums, int k) { //构建最大堆 buildHeap(nums); int n = nums.size(); // pop k-1个元素 for (int i = n - 1; i &gt; n - k; i--) { swap(nums[0], nums[i]); shiftDown(nums, 0, i); } return nums[0]; }}; 优先队列其内部可以看作是一棵由数组模拟的完全二叉树，对于这棵树的每一个结点来说，自身的优先级不低于左右孩子的优先级，所以其功能就是拿出优先级最大的元素，如何简单使用C++中内置容器priority_queue？首先引出头文件&lt;queue&gt;，定义一个默认的优先队列（大顶堆）priority_queue&lt;int&gt; que;即值越大的元素优先级越高先出队。 que.size() 元素数量 que.push(x) 插入x que.pop() 删除优先级最高的元素 que.top() 访问优先级最高的元素（堆顶元素） que.empty() 判空 对于优先队列的操作，插入删除的时间复杂度为对数级，访问堆顶元素时间复杂度为常数级，所以比较适合动态调整，获得极值。 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;//大顶堆int main(){ priority_queue&lt;int&gt; que; que.push(7); que.push(5); que.push(-2); que.push(1); que.push(6); cout &lt;&lt; que.size() &lt;&lt; endl; while (!que.empty()) { cout &lt;&lt; que.top() &lt;&lt; &quot; &quot;; que.pop(); } cout &lt;&lt; endl; return 0;} 如何定义一个小顶堆？优先队列除了第一个数据类型以外，还有其他两个模板参数：底层顺序结构类型（默认是vector，也可使用queue或者array），第三个参数是一个仿函数，提供优先队列权值比较方法。 12priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; q; //大顶堆priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; //小顶堆 其中greater&lt;int&gt;和less&lt;int&gt;即为仿函数，其中greater的实现如下 12345678template &lt;class T&gt;struct greater : public binary_function&lt;T, T, bool&gt;{ bool operator()(const T &amp;x, const T &amp;y) const { return x &gt; y; }} 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;//小顶堆int main(){ priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; que; que.push(7); que.push(5); que.push(-2); que.push(1); que.push(6); cout &lt;&lt; que.size() &lt;&lt; endl; while (!que.empty()) { cout &lt;&lt; que.top() &lt;&lt; &quot; &quot;; que.pop(); } cout &lt;&lt; endl; return 0;} 定义一个自定义类型的优先队列 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct node{ int x, y; //重载运算符，重载小于号，若需小根堆，this-&gt;x &gt; b.x 即可 bool operator&lt;(const node &amp;b) const { return this-&gt;x &lt; b.x; }};int main(){ priority_queue&lt;node&gt; que; que.push((node){1, 5}); que.push((node){2, 3}); que.push((node){9, 4}); que.push((node){-5, 5}); while (!que.empty()) { cout &lt;&lt; que.top().x &lt;&lt; endl; que.pop(); } return 0;} 12345[root@VM-12-16-centos lab]# ./a.out 921-5","link":"/2022/07/10/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"}],"tags":[{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"树的遍历","slug":"树的遍历","link":"/tags/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"},{"name":"递归解法","slug":"递归解法","link":"/tags/%E9%80%92%E5%BD%92%E8%A7%A3%E6%B3%95/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"非自顶向下","slug":"非自顶向下","link":"/tags/%E9%9D%9E%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/"},{"name":"刷题","slug":"刷题","link":"/tags/%E5%88%B7%E9%A2%98/"},{"name":"CPP","slug":"CPP","link":"/tags/CPP/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"递归求解","slug":"递归求解","link":"/tags/%E9%80%92%E5%BD%92%E6%B1%82%E8%A7%A3/"},{"name":"指针","slug":"指针","link":"/tags/%E6%8C%87%E9%92%88/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"堆","slug":"堆","link":"/tags/%E5%A0%86/"},{"name":"优先队列","slug":"优先队列","link":"/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"}],"categories":[{"name":"盲人摸象","slug":"盲人摸象","link":"/categories/%E7%9B%B2%E4%BA%BA%E6%91%B8%E8%B1%A1/"}]}