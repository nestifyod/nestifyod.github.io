{"pages":[{"title":"Gallery","text":"","link":"/album/index.html"}],"posts":[{"title":"二叉树中的最大路径和","text":"题目路径被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中至多出现一次。该路径至少包含一个节点，且不一定经过根节点。 路径和 是路径中各节点值的总和。 给你一个二叉树的根节点 root ，返回其 最大路径和 。 输入：root = [-10,9,20,null,null,15,7]输出：42解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42 递归林小鹿 路径 在这道题目中，路径是指从树中某个节点开始，沿着树中的边走，走到某个节点为止，路过的所有节点的集合。路径的权值和是指路径中所有节点的权值的总和。 对于一棵树，我们可以将其划分为很多的子树，如下图所示，虚线矩形围起来的子树。我们把这颗子树的蓝色节点称为该子树最高节点。用最高节点可以将整条路径分为两部分：从该节点向左子树延伸的路径，和从该节点向右子树延伸的部分。 递归遍历整棵树，递归时维护从每个子树从最高节点开始往下延伸的最大路径和。 对于每个子树的最高节点，递归计算完左右子树后，我们将左右子树维护的两条最大路径，和该点拼接起来，就可以得到以这个点为最高节点子树的最大路径。（这条路径一定是：左子树路径-&gt;最高节点-&gt;右子树路径）然后维护从这个点往下延伸的最大路径：从左右子树的路径中选择权值大的一条延伸即可。（只能从左右子树之间选一条路径）最后整颗树的最大路径和为: 根节点值+左子树最大路径和+右子树最大路径和，即left_max + right_max + root-&gt;val 注意 如果某条路径之和小于0，那么我们选择不走该条路径，因此其路径之和应和0之间取最大值。 时间复杂度分析: 每个节点仅会遍历一次，所以时间复杂度是 O(n)。 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: int res = INT_MIN; int maxPathSum(TreeNode* root) { dfs(root); return res; } int dfs(TreeNode* root){ if(!root) return 0; int left = max(0, dfs(root-&gt;left)), right = max(0, dfs(root-&gt;right)); res = max(res, root-&gt;val + left + right); return root-&gt;val + max(left, right); }}; DFS-非自顶而下作者：eh-xing-qing总结得实在好 非自顶而下 这类题目一般解题思路如下：设计一个辅助函数maxpath，调用自身求出以一个节点为根节点的左侧最长路径left和右侧最长路径right，那么经过该节点的最长路径就是left+right接着只需要从根节点开始dfs，不断比较更新全局变量即可 12345678910int res=0;int maxPath(TreeNode *root) //以root为路径起始点的最长路径{ if (!root) return 0; int left=maxPath(root-&gt;left); int right=maxPath(root-&gt;right); res = max(res, left + right + root-&gt;val); //更新全局变量 return max(left, right); //返回左右路径较长者} 这类题型DFS注意点 left,right代表的含义要根据题目所求设置，比如最长路径、最大路径和等等 全局变量res的初值设置是0还是INT_MIN要看题目节点是否存在负值,如果存在就用INT_MIN，否则就是0 注意两点之间路径为1，因此一个点是不能构成路径的 1234567891011121314151617181920class Solution{public: int res = INT_MIN; //注意节点值可能为负数，因此要设置为最小值 int maxPathSum(TreeNode *root) { maxPath(root); return res; } int maxPath(TreeNode *root) //以root为路径起始点的最长路径 { if (!root) return 0; int left = max(maxPath(root-&gt;left), 0); int right = max(maxPath(root-&gt;right), 0); res = max(res, left + right + root-&gt;val); //比较当前最大路径和与左右子树最长路径加上根节点值的较大值，更新全局变量 return max(left + root-&gt;val, right + root-&gt;val); //返回左右子树较长的路径加上根节点值 }};","link":"/2022/07/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"},{"title":"二叉树的最近公共祖先","text":"题目给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出：3解释：节点 5 和节点 1 的最近公共祖先是节点 3 。 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出：5解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。 输入：root = [1,2], p = 1, q = 2输出：1","link":"/2022/07/14/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"},{"title":"二叉树的下一个结点","text":"题目给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 分析二叉树的下一个节点，一共有以下情况： 二叉树为空，则返回空； 节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点； 节点不是根节点。如果该节点是其父节点的左孩子，则返回父节点；否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果。 12345678910111213141516171819202122232425262728/*struct TreeLinkNode { int val; struct TreeLinkNode *left; struct TreeLinkNode *right; struct TreeLinkNode *next; //父节点 TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) { }};*/class Solution {public: TreeLinkNode* GetNext(TreeLinkNode* pNode) { if(pNode-&gt;right) { //如果有右子树，则找右子树的最左节点 TreeLinkNode *p = pNode-&gt;right; while(p-&gt;left) p = p-&gt;left; return p; } TreeLinkNode *p = pNode; while(p-&gt;next) { //没右子树，则找第一个当前节点是父节点左孩子的节点 if(p-&gt;next-&gt;left == p) return p-&gt;next; p = p-&gt;next; } return nullptr; //退到了根节点仍没找到，则返回null }}; 复习 前序遍历：F, B, A, D, C, E, G, I, H中序遍历：A, B, C, D, E, F, G, H, I后序遍历：A, C, E, D, B, H, I, G, F层次遍历：F, B, G, A, D, I, C, E, H","link":"/2022/07/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9/"},{"title":"向量","text":"简介向量vector是可以改变其大小的线性序列容器，像数组一样，向量使用连续的空间存储元素，这表明向量可以像数组一样通过下标来访问其元素，但不同于数组的是，向量的大小可以动态变化。 12345678910111213141516171819202122232425262728293031323334//常用操作#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;using namespace std;vector&lt;int&gt; myVector;int main(){ for (int i = 0; i &lt; 5; ++i) { myVector.push_back(i); //从尾部逐一添加元素 } myVector.insert(myVector.begin(), 3, 15); //头部插入3个15 myVector.pop_back(); for (int i = 0; i &lt; myVector.size(); ++i) { printf(&quot;%d &quot;, myVector[i]); } printf(&quot;\\n&quot;); printf(&quot;the 5th element of myVector:%d\\n&quot;, myVector[4]); printf(&quot;the size of myVector:%d\\n&quot;, myVector.size()); myVector.erase(myVector.begin() + 5, myVector.end()); //删除第5后续的元素 vector&lt;int&gt;::iterator it; //定义迭代器 for (it = myVector.begin(); it != myVector.end(); it++) { printf(&quot;%d &quot;, *it); //遍历向量 } printf(&quot;\\n&quot;); myVector.clear(); return 0;} 123415 15 15 0 1 2 3the 5th element of myVector:1the size of myVector:715 15 15 0 1 向量的应用完数与盈数一个数如果恰好等于它的各因子(该数本身除外)之和，如：6=3+2+1。则称其为“完数”；若因子之和大于该数，则称其为“盈数”。 求出2到60之间所有“完数”和“盈数”。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;using namespace std;vector&lt;int&gt; numberE; //完数vector&lt;int&gt; numberG; //盈数int Sum(int x){ int sum = 0; for (int i = 1; i &lt; x; ++i) { if (x % i == 0) { sum += i; } } return sum;}int main(){ for (int i = 2; i &lt;= 60; ++i) { if (i == Sum(i)) { numberE.push_back(i); } else if (i &lt; Sum(i)) { numberG.push_back(i); } } printf(&quot;E:&quot;); for (int i = 0; i &lt; numberE.size(); ++i) { printf(&quot;%d &quot;, numberE[i]); } printf(&quot;\\n&quot;); printf(&quot;G:&quot;); for (int i = 0; i &lt; numberG.size(); ++i) { printf(&quot;%d &quot;, numberG[i]); } printf(&quot;\\n&quot;); return 0;} 12E:6 28G:12 18 20 24 30 36 40 42 48 54 56 60","link":"/2022/06/03/%E5%90%91%E9%87%8F/"},{"title":"堆排序","text":"什么是堆如果有一个关键码的集合K={k_0,k_1,k_2,…,k_{n-1}}，把它的所有元素按完全二叉树的顺序存储方式存储在一个一维数组中，并满足ki&lt;=k_{2i+1}且ki&lt;=k_{2i+2}（或满足ki&gt;=k_{2i+1}且ki&gt;=k_{2i+2}），其中i=0,1,2,…则称该集合为堆。 小堆：对于一棵完全二叉树，满足任一节点都比其孩子节点小，也就是将根结点为最小元素的堆叫做小堆，也叫最小堆或小根堆。 大堆：对于一棵完全二叉树，满足任一节点都比其孩子节点大，也就是将根结点为最大元素的堆叫做大堆，也叫最大堆或大根堆。 堆的性质 堆中某个结点的值总是不大于或不小于其父结点的值。 堆总是一棵完全二叉树。 堆的向下调整假设：节点的左右子树都是堆（大/小），但是其自身不是堆，可以通过一次向下的调整来将其变换成一个堆。以调整至大堆为例 从根结点处开始，选出左右孩子中值较大的孩子。 让较大的孩子与其父亲进行比较。 若较大的孩子比父亲大，则该孩子与其父亲的位置进行交换。并将原来小的孩子的位置当成父亲继续向下进行调整，直到调整到叶子结点为止。 若较大的孩子比父亲小，则不需处理了，调整完成，整个树已经是大堆了。12345678910111213141516171819202122def sift(li,low,high): ''' :param li:列表 :param low:堆的根节点位置 :param high:堆的最后一个元素的位置 :return: ''' i = low #父节点 j=2*i+1 #左孩子 tmp=li[low] #堆顶存储 while j&lt;=high: #只要左孩子没越界 if j+1&lt;=high and li[j+1]&gt;li[j]: #如果有右孩子,并且右孩子比较大,别忘了前提需要保证j+1位置不越界 j=j+1 #j指向右孩子位置 if li[j]&gt;tmp: li[i]=li[j] i=j #往下看一层 j=2*i+1 else: #如果tmp更大,把tmp放到i的位置上 li[i]=tmp break else: #别忘了考虑,如果当堆顶元素的左孩子已经越界,直接将其存入li[i] li[i]=tmp 全过程 建立堆，得到堆顶元素，为最大元素12345678910111213141516171819202122232425262728293031323334def sift(li,low,high): ''' :param li:列表 :param low:堆的根节点位置 :param high:堆的最后一个元素的位置 :return: ''' i = low #父节点 j=2*i+1 #左孩子 tmp=li[low] #堆顶存储 while j&lt;=high: #只要左孩子没越界 if j+1&lt;=high and li[j+1]&gt;li[j]: #如果有右孩子,并且右孩子比较大,别忘了还要保证j+1位置不越界 j=j+1 #j指向右孩子位置 if li[j]&gt;tmp: li[i]=li[j] i=j #往下看一层 j=2*i+1 else: # 不管怎么样都得把这个空补上，直接脱到最后执行 break li[i]=tmpdef heapCreate(li): n=len(li) for i in range((n-2)//2,-1,-1): #i表示建堆的时候调整的部分根下标 sift(li,i,n-1) #堆建立完成# 验证import randomli=[i for i in range(16)]random.shuffle(li)print(li)heapCreate(li)print(li) 12[9, 13, 15, 6, 14, 8, 12, 7, 11, 1, 2, 3, 4, 10, 5, 0][15, 14, 12, 11, 13, 8, 10, 7, 6, 1, 2, 3, 4, 9, 5, 0] 去掉堆顶，将堆最后一个元素放到堆顶，**实质上交换了堆顶元素和堆尾元素，但是需要注意交换后的堆尾元素并不是原来的堆顶元素，而应当是原堆尾元素的左边紧挨着的那一个元素，所以接下来的调整传入的堆尾索引也就是high为i-1**，接着可通过一次调整重新使得堆有序 堆顶元素为第二大元素 重复步骤2，直到堆空12345678910111213141516171819202122232425262728293031323334353637def sift(li,low,high): ''' :param li:列表 :param low:堆的根节点位置 :param high:堆的最后一个元素的位置 :return: ''' i = low #父节点 j=2*i+1 #左孩子 tmp=li[low] #堆顶存储 while j&lt;=high: #只要左孩子没越界 if j+1&lt;=high and li[j+1]&gt;li[j]: #如果有右孩子,并且右孩子比较大,别忘了还要保证j+1位置不越界 j=j+1 #j指向右孩子位置 if li[j]&gt;tmp: li[i]=li[j] i=j #往下看一层 j=2*i+1 else: # 不管怎么样都得把这个空补上，直接脱到最后执行 break li[i]=tmpdef heapSort(li): n=len(li) for i in range((n-2)//2,-1,-1): #i表示建堆的时候调整的部分根下标 sift(li,i,n-1) #堆建立完成 for i in range(n-1,-1,-1): #i指向当前堆的最后一个元素 li[0],li[i]=li[i],li[0] #先交换堆顶元素和堆尾元素 sift(li,0,i-1) #i-1为新的high# 验证import randomli=[i for i in range(16)]random.shuffle(li)print(li)heapSort(li)print(li) 12[7, 5, 11, 12, 14, 0, 15, 4, 13, 9, 6, 8, 10, 2, 1, 3][0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] 时间复杂度分为两部分，第一部分向下调整 1234567891011121314def sift(li,low,high): i = low j=2*i+1 tmp=li[low] while j&lt;=high: if j+1&lt;=high and li[j+1]&gt;li[j]: j=j+1 if li[j]&gt;tmp: li[i]=li[j] i=j j=2*i+1 else: break li[i]=tmp 这一部分，相当于走了一遍完全二叉树的深度，设元素个数为n，深度即为log(n+1) 相当于logn （根据深度为h，结点数最多为2^h-1） 12345678def heapSort(li): n=len(li) for i in range((n-2)//2,-1,-1): sift(li,i,n-1) #堆建立完成 for i in range(n-1,-1,-1): li[0],li[i]=li[i],li[0] sift(li,0,i-1) 第二部分为建堆，逐个出数，外层循环部分均为$n$，而内层为调整函数，所以总的时间复杂度为$O(nlogn)$ C++版本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;void max_heapify(vector&lt;int&gt;&amp; nums, int start, int end){ int dad = start; int son = dad * 2 + 1; while (son &lt;= end) { if (son + 1 &lt;= end &amp;&amp; nums[son] &lt; nums[son + 1]) { son++; } if (nums[dad] &gt; nums[son]) { return; } else { swap(nums[dad], nums[son]); dad = son; son = dad * 2 + 1; } }}void heap_sort(vector&lt;int&gt;&amp; nums, int len){ for (int i = len / 2 - 1; i &gt;= 0; i--) { max_heapify(nums, i, len - 1); } for (int i = len - 1; i &gt; 0; i--) { swap(nums[0], nums[i]); max_heapify(nums, 0, i - 1); }}int main() { int num; vector&lt;int&gt; int_array; while (cin &gt;&gt; num) { int_array.push_back(num); if (cin.get() == '\\n')break; } int len = int_array.size(); heap_sort(int_array, len); for (int n : int_array)cout &lt;&lt; n &lt;&lt; &quot; &quot;; return 0;} topk问题现在有n个数，设计算法得到前k大的数（k&lt;n） 解决思路 排序后切片 O(nlogn) 冒泡、插入、选择排序 O(kn) 堆排序 O(klogn) 取列表前k个元素建立一个小根堆，堆顶就是目前第k大的数；依次向后遍历原列表，对于列表中的元素，如果小于堆顶，则忽略该元素；如果大于堆顶，则将堆顶更换为该元素，并且对堆进行一次调整；遍历列表所有元素后，倒序弹出堆顶。 比如 6 8 1 9 3 0 7 2 4 5 拿出前五个数，建立一个小根堆 剩下 0 7 2 4 5 0&lt;1 0舍 1不动 剩下 7 2 4 5 7&gt;1 1舍 7上 剩下 2 4 5 7&gt;3 小根堆调整 7、3对调 剩下 2 4 5 2&lt;3 2舍 3不动 剩下4 5 4&gt;3 3舍 4上 剩下5 5&gt;4 4舍5上 具体怎么做？基本就是小根堆版本 12345678910111213141516171819202122232425262728293031323334353637383940def sift(li,low,high): ''' :param li:列表 :param low:堆的根节点位置 :param high:堆的最后一个元素的位置 :return: ''' i = low #父节点 j=2*i+1 #左孩子 tmp=li[low] #堆顶存储 while j&lt;=high: #只要左孩子没越界 if j+1&lt;=high and li[j+1]&lt;li[j]: #如果有右孩子,并且右孩子比较小,别忘了还要保证j+1位置不越界 j=j+1 #j指向右孩子位置 if li[j]&lt;tmp: li[i]=li[j] i=j #往下看一层 j=2*i+1 else: # 不管怎么样都得把这个空补上，直接脱到最后执行 break li[i]=tmpdef topk(li,k): heap=li[0:k] #取前k个数 for i in range((k-2)//2,-1,-1): sift(heap,i,k-1) #1.小根堆建立完成 for i in range(k,len(li)): if li[i]&gt;heap[0]: heap[0]=li[i] sift(heap,0,k-1) #2.遍历列表里剩下的所有元素完成 for i in range(k-1,-1,-1): #i指向当前堆的最后一个元素 heap[0],heap[i]=heap[i],heap[0] #先交换堆顶元素和堆尾元素 sift(heap,0,i-1) #i-1为新的high #3.挨个出数完成 return heapli=[6,8,1,9,3,0,7,2,4,5]print(li)print(topk(li,5))","link":"/2022/05/14/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"title":"反转链表","text":"题目给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 输入：head = [1,2,3,4,5]输出：[5,4,3,2,1] 递归路漫漫我不畏 使用递归函数，一直递归到链表的最后一个结点，该结点就是反转后的头结点，记作 cur 此后，每次函数在返回的过程中，让当前结点的下一个结点的 next 指针指向当前节点 同时让当前结点的 next 指针指向 NULL ，从而实现从链表尾部开始的局部反转 当递归函数全部出栈后，链表反转完成 123456789101112131415class Solution{public: ListNode *reverseList(ListNode *head) { if (head == NULL || head-&gt;next == NULL) { return head; } ListNode *cur = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return cur; }}; 简单的双指针 定义双指针：pre 和 cur 局部反转：pre-&gt;next=cur pre 和 cur 同时右移一个位置 循环上述过程，直至 pre 到达链表尾部 12345678910111213141516class Solution{public: ListNode *reverseList(ListNode *head) { ListNode *cur = NULL, *pre = head; while (pre != NULL) { ListNode *tmp = pre-&gt;next; pre-&gt;next = cur; cur = pre; pre = tmp; } return cur; }}; 较复杂的双指针 定义指针 cur ，初始化为 head 局部反转：head-&gt;next 的 next 指向 cur cur 和 head-&gt;next 同时右移一个位置 循环上述过程，直至 cur 到达链表尾部 1234567891011121314151617181920class Solution{public: ListNode *reverseList(ListNode *head) { if (head == NULL) { return NULL; } ListNode *cur = head; while (head-&gt;next != NULL) { ListNode *t = head-&gt;next-&gt;next; head-&gt;next-&gt;next = cur; cur = head-&gt;next; head-&gt;next = t; } return cur; }};","link":"/2022/07/11/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"title":"希尔排序","text":"回顾插入排序 12345678def insertSort(li): for i in range(1,len(li)): #i表示摸到的牌的下标,注意循环从1开始,因为手里的牌是0 tmp=li[i] j=i-1 #j表示手里的牌的下标 while j&gt;=0 and li[j]&gt;tmp: #如果手里的牌比tmp小或者手里已经没有牌了,结束循环 li[j+1]=li[j] j-=1 li[j+1]=tmp 希尔排序现在，希尔排序在插入排序的基础上，设置了间隔gap，实现了分组插入排序 首先取一个整数d1=n/2，将元素分为d1个组，每组相邻两元素之间间距为d1，在个组内进行直接插入排序 取第二个整数d2=d1/2，重复上述分组排序过程，直到di=1，即所有元素在同一组内进行直接插入排序 希尔排序每趟并不能使某些元素有序，而是使整体数据越来越接近有序；最有一趟使得所有数据有序。 1234567891011121314151617181920212223def insertSort_gap(li,gap): for i in range(gap,len(li)): #i表示摸到的牌的下标,注意循环从gap开始,因为手里的牌是0~(gap-1) tmp=li[i] j=i-gap #j表示手里的牌的下标 while j&gt;=0 and li[j]&gt;tmp: #如果手里的牌比tmp小或者手里已经没有牌了,结束循环 li[j+gap]=li[j] j-=gap li[j+gap]=tmpdef shell_sort(li): d=len(li)//2 while d&gt;=1: insertSort_gap(li,d) d//=2# 验证import randomli=list(range(10))random.shuffle(li)print(li)shell_sort(li)print(li) 12[1, 9, 8, 5, 2, 0, 4, 6, 7, 3][0, 1, 2, 3, 4, 5, 6, 7, 8, 9]","link":"/2022/05/12/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"},{"title":"归并排序","text":"基本思路一次归并 假设左右部分都已经排好序 123456789101112131415161718192021222324def merge(li,low,mid,high): i=low j=mid+1 tmp=[] while i&lt;=mid and j&lt;=high: if li[i]&lt;li[j]: tmp.append(li[i]) i+=1 else: tmp.append(li[j]) j+=1 while i&lt;=mid: tmp.append(li[i]) i+=1 while j&lt;=high: tmp.append(li[j]) j+=1 li[low:high+1]=tmp# 验证li=[2,4,6,8,1,3,5,7]print(li)merge(li,0,3,7)print(li) 12[2, 4, 6, 8, 1, 3, 5, 7][1, 2, 3, 4, 5, 6, 7, 8] 先分解 将列表越分越小，直至分成一个元素，使用递归 剩下合并其实就是上面的一次归并 12345678910111213141516171819202122232425262728293031323334def merge(li,low,mid,high): i=low j=mid+1 tmp=[] while i&lt;=mid and j&lt;=high: if li[i]&lt;li[j]: tmp.append(li[i]) i+=1 else: tmp.append(li[j]) j+=1 while i&lt;=mid: tmp.append(li[i]) i+=1 while j&lt;=high: tmp.append(li[j]) j+=1 li[low:high+1]=tmpdef merge_sort(li,low,high): if low&lt;high: #至少两个元素,递归 mid=(low+high)//2 merge_sort(li,low,mid) merge_sort(li,mid+1,high) merge(li,low,mid,high)# 验证import randomli=list(range(16))random.shuffle(li)print(li)merge_sort(li,0,len(li)-1)print(li) 12[14, 3, 5, 11, 6, 9, 8, 7, 4, 15, 0, 12, 1, 10, 13, 2][0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] 为了更加直观地看到分解以及合并的递归过程，我们对merge_sort()函数稍作修改 1234567def merge_sort(li,low,high): if low&lt;high: #至少两个元素,递归 mid=(low+high)//2 merge_sort(li,low,mid) merge_sort(li,mid+1,high) print(li[low:high+1]) merge(li,low,mid,high) 1234567891011121314151617[10, 9, 8, 13, 14, 4, 1, 2, 7, 6, 15, 5, 11, 0, 3, 12][10, 9][8, 13][9, 10, 8, 13][14, 4][1, 2][4, 14, 1, 2][8, 9, 10, 13, 1, 2, 4, 14][7, 6][15, 5][6, 7, 5, 15][11, 0][3, 12][0, 11, 3, 12][5, 6, 7, 15, 0, 3, 11, 12][1, 2, 4, 8, 9, 10, 13, 14, 0, 3, 5, 6, 7, 11, 12, 15][0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] C++1234567891011121314151617181920212223242526272829303132333435363738394041#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; t;void mergesort(vector&lt;int&gt;&amp; a, int low, int high) { if (low &gt;= high) return; int mid = (low + high) &gt;&gt; 1; mergesort(a, low, mid); mergesort(a, mid + 1, high); int i = low, j = mid + 1, idx = low; while (i &lt;= mid || j &lt;= high) { if (i &lt;= mid &amp;&amp; j &lt;= high) { if (a[i] &lt;= a[j]) t[idx] = a[i++]; else t[idx] = a[j++]; } else if (i &lt;= mid) { t[idx] = a[i++]; } else { t[idx] = a[j++]; } idx++; } for (int k = low; k &lt;= high; k++) a[k] = t[k];}int main() { int num; vector&lt;int&gt; a; while (cin &gt;&gt; num) { a.push_back(num); if (cin.get() == '\\n')break; } t.resize(a.size()); mergesort(a, 0, a.size() - 1); for (int n : a)cout &lt;&lt; n &lt;&lt; &quot; &quot;; return 0;} 时间复杂度从图入手，每一层相当于把整个列表遍历一遍，O(n)；总共logn层，所以合并也就是一半部分的时间复杂度为O(nlogn)。 还有因为归并排序不是”原地排序”，我们开了一个临时空间tmp，所以空间复杂度为O(n)。","link":"/2022/05/15/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"title":"快速排序","text":"基于分治的思想，首先在数组中选择一个基准点，选取基准点的效率决定了时间复杂度，从数组两端扫描数组，设置low 和 high两个索引，图中蓝标代表low红标代表high，橘色表代表重合位置 首次分割，数列被分成了两个子数列，长度分别是i-1和n-i，排序时间表示为T(i-1)和T(n-i)，计算总时间还得加上分割操作的时间，分割操作只用了循环while(low&lt;high)，此段时间记为cn，所以Tn = T(i-1)+T(n-i)+cn； 演示1234567891011121314151617181920212223242526272829303132333435363738394041424344public class quicksort { public static void main(String[] args) { int[] arr = { 23, 46, 0, 8, 11, 18 }; quickSort(arr, 0, arr.length - 1); System.out.print(&quot;排序后 &quot;); for (int i : arr) { System.out.print(i+&quot; &quot;); } } private static void quickSort(int[] arr, int low, int high) { if (low &lt; high) { // 找寻基准数据的正确索引 int index = getIndex(arr, low, high); // 进行迭代对index之前和之后的数组进行相同的操作使整个数组变成有序 //quickSort(arr, 0, index - 1); 之前的版本，这种姿势有很大的性能问题，谢谢大家的建议 quickSort(arr, low, index - 1); quickSort(arr, index + 1, high); } } private static int getIndex(int[] arr, int low, int high) { // 基准数据 int tmp = arr[low]; while (low &lt; high) { // 当队尾的元素大于等于基准数据时,向前挪动high指针 while (low &lt; high &amp;&amp; arr[high] &gt;= tmp) { high--; } // 如果队尾元素小于tmp了,需要将其赋值给low arr[low] = arr[high]; // 当队首元素小于等于tmp时,向前挪动low指针 while (low &lt; high &amp;&amp; arr[low] &lt;= tmp) { low++; } // 当队首元素大于tmp时,需要将其赋值给high arr[high] = arr[low]; } // 跳出循环时low和high相等,此时的low或high就是tmp的正确索引位置 // 由原理部分可以很清楚的知道low位置的值并不是tmp,所以需要将tmp赋值给arr[low] arr[low] = tmp; return low; // 返回tmp的正确位置 }} 最坏的情况数列每次分割得到的两个子数列长度为n-1和0，也就是其中的每一个元素都要移动n次，总时间T(n^2) 123456789101112T(n) = T(n - 1) + C*n T(n - 1) = T(n - 2) + C*(n - 1) # 将 n 减 1，得到下个子序列T(n - 2) = T(n - 3) + C*(n - 3)....T(2) = T(1) + C*2T(1) = T(0) + C# 将下一级表达式代入上一级T(n) = T(0) + C*n + C*(n-1) + C*(n-2) + C*(n-3).....+C*(2)+C# T(0)是等于0的T(n) = C*n + C*(n-1) + C*(n-2) + C*(n-3).....+C*(2)+CT(n) = C*[n + (n-1) + (n-2) + (n-3).....+2+1]T(n) = C*(n + 1)*n/2 最高阶为n^2，最差时间复杂度为O(n^2) 最好情况数列每次分割得到的两个子数列长度等长，除分割时间以外左右各为T(n/2)，总时间2T(n/2)+cn 12345678910T(n) = 2T(n / 2) + C*n T(n / 2) = 2T(n / 4) + C*n / 2 T(n / 4) = 2T(n / 8) + C*n / 4 ....# 将下一级表达式代入上一级，化简找到通项T(n) = 2^k*T（n/2^k）+ kcn# 当n/2^k-&gt;1， k = lg2nT(n) = nT(1) + cnlg2n 最优时间复杂度为O(nlgn) 平均时间复杂度 &lt;&lt;算法导论&gt;&gt; p98 p99","link":"/2021/10/01/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"title":"数组中的第K个最大元素","text":"题目给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 输入：[3,2,3,1,2,4,5,5,6] 和 k = 4输出：4 暴力求解1234567891011121314#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution {public: int findKthLargest(vector&lt;int&gt; &amp;nums, int k) { int size = nums.size(); sort(begin(nums), end(nums)); return nums[size - k]; }}; 大顶堆调用priority_queue 12345678910111213class Solution{public: int findKthLargest(vector&lt;int&gt; &amp;nums, int k) { priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; maxHeap; for (int x : nums) maxHeap.push(x); for (int _ = 0; _ &lt; k - 1; _++) maxHeap.pop(); return maxHeap.top(); }}; NB solution 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution{public: void shiftDown(vector&lt;int&gt; &amp;nums, int i, int len) { int root = i; while (root &lt; len) { int tmp = root; int left = 2 * root + 1, right = 2 * root + 2; if (left &lt; len &amp;&amp; nums[root] &lt; nums[left]) { root = left; } if (right &lt; len &amp;&amp; nums[root] &lt; nums[right]) { root = right; } if (root == tmp) { break; } swap(nums[tmp], nums[root]); } } void buildHeap(vector&lt;int&gt; &amp;nums) { int n = nums.size(); for (int i = n / 2 - 1; i &gt;= 0; i--) { shiftDown(nums, i, n); } } int findKthLargest(vector&lt;int&gt; &amp;nums, int k) { //构建最大堆 buildHeap(nums); int n = nums.size(); // pop k-1个元素 for (int i = n - 1; i &gt; n - k; i--) { swap(nums[0], nums[i]); shiftDown(nums, 0, i); } return nums[0]; }}; 优先队列其内部可以看作是一棵由数组模拟的完全二叉树，对于这棵树的每一个结点来说，自身的优先级不低于左右孩子的优先级，所以其功能就是拿出优先级最大的元素，如何简单使用C++中内置容器priority_queue？首先引出头文件&lt;queue&gt;，定义一个默认的优先队列（大顶堆）priority_queue&lt;int&gt; que;即值越大的元素优先级越高先出队。 que.size() 元素数量 que.push(x) 插入x que.pop() 删除优先级最高的元素 que.top() 访问优先级最高的元素（堆顶元素） que.empty() 判空 对于优先队列的操作，插入删除的时间复杂度为对数级，访问堆顶元素时间复杂度为常数级，所以比较适合动态调整，获得极值。 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;//大顶堆int main(){ priority_queue&lt;int&gt; que; que.push(7); que.push(5); que.push(-2); que.push(1); que.push(6); cout &lt;&lt; que.size() &lt;&lt; endl; while (!que.empty()) { cout &lt;&lt; que.top() &lt;&lt; &quot; &quot;; que.pop(); } cout &lt;&lt; endl; return 0;} 如何定义一个小顶堆？优先队列除了第一个数据类型以外，还有其他两个模板参数：底层顺序结构类型（默认是vector，也可使用queue或者array），第三个参数是一个仿函数，提供优先队列权值比较方法。 12priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; q; //大顶堆priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; //小顶堆 其中greater&lt;int&gt;和less&lt;int&gt;即为仿函数，其中greater的实现如下 12345678template &lt;class T&gt;struct greater : public binary_function&lt;T, T, bool&gt;{ bool operator()(const T &amp;x, const T &amp;y) const { return x &gt; y; }} 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;//小顶堆int main(){ priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; que; que.push(7); que.push(5); que.push(-2); que.push(1); que.push(6); cout &lt;&lt; que.size() &lt;&lt; endl; while (!que.empty()) { cout &lt;&lt; que.top() &lt;&lt; &quot; &quot;; que.pop(); } cout &lt;&lt; endl; return 0;} 定义一个自定义类型的优先队列 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct node{ int x, y; //重载运算符，重载小于号，若需小根堆，this-&gt;x &gt; b.x 即可 bool operator&lt;(const node &amp;b) const { return this-&gt;x &lt; b.x; }};int main(){ priority_queue&lt;node&gt; que; que.push((node){1, 5}); que.push((node){2, 3}); que.push((node){9, 4}); que.push((node){-5, 5}); while (!que.empty()) { cout &lt;&lt; que.top().x &lt;&lt; endl; que.pop(); } return 0;} 12345[root@VM-12-16-centos lab]# ./a.out 921-5","link":"/2022/07/10/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"},{"title":"栈","text":"简介和队列一样，栈stack也是一种线性序列结构，其存放的元素也是按照线性逻辑次序排列的，然而，与一般的线性结构相比，栈的操作仅限于逻辑上特定的一端，即新元素只能从栈的一端插入，也只能从这一端删除已有的元素。栈中允许元素插入和删除的一端称为栈顶，禁止操作的盲端称为栈底。于是，插入元素和删除元素就分别成为入栈和出栈。 12345678910111213141516171819202122232425262728293031//常规操作#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;cstdio&gt;using namespace std;stack&lt;int&gt; myStack;int main(){ printf(&quot;the size of myStack:%d\\n&quot;, myStack.size()); for (int i = 0; i &lt; 10; ++i) { myStack.push(i); } printf(&quot;the top of myStack:%d\\n&quot;, myStack.top()); printf(&quot;the size of myStack:%d\\n&quot;, myStack.size()); int sum = 0; while (!myStack.empty()) { sum += myStack.top(); myStack.pop(); } printf(&quot;sum:%d\\n&quot;, sum); if (myStack.empty()) { printf(&quot;myStack is empty&quot;); } return 0;} 12345the size of myStack:0the top of myStack:9the size of myStack:10sum:45myStack is empty 栈的应用逆序输出You are given a sequence of integer numbers. Zero-complexity transposition of the sequence is the reverse of this sequence. Your task is to write a program that prints zero-complexity transposition of the given sequence. 输入描述For each case, the first line of the input file contains one integer n-length of the sequence (0 ＜ n ≤ 10 000). The second line contains n integers numbers-a1, a2, …, an (-1 000 000 000 000 000 ≤ ai ≤ 1 000 000 000 000 000). 输出描述For each case, on the first line of the output file print the sequence in the reverse order. 输入 125-3 4 6 -8 9 输出 19 -8 6 4 -3 测试代码 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;cstdio&gt;using namespace std;stack&lt;long long&gt; reverse;int main(){ int num; while (scanf(&quot;%d&quot;, &amp;num) != EOF) { while (num--) { long long number; scanf(&quot;%lld&quot;, &amp;number); reverse.push(number); } while (!reverse.empty()) { printf(&quot;%lld &quot;, reverse.top()); reverse.pop(); } printf(&quot;\\n&quot;); } return 0;} 1235-3 4 6 -8 99 -8 6 4 -3 括号匹配问题输出包括两行，第一行输出原始输入字符，第二行由$ ?和空格组成，$ ?分别代表与之对应的左括号和右括号无法匹配。 样例输入 1)(rttyy())sss)( 输出 12)(rttyy())sss)(? ?$ 测试代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;stack&lt;int&gt; brackets;int main(){ string str; while (cin &gt;&gt; str) { string answer(str.size(), ' '); //设定为输入空格个长度 for (int i = 0; i &lt; str.size(); ++i) { if (str[i] == '(') { brackets.push(i); //压入左括号的下标 } else if (str[i] == ')') { if (!brackets.empty()) { brackets.pop(); } else { answer[i] = '?'; //右括号不匹配 } } } while (!brackets.empty()) { answer[brackets.top()] = '$'; brackets.pop(); } cout &lt;&lt; str &lt;&lt; endl; cout &lt;&lt; answer &lt;&lt; endl; } return 0;} 123)(rttyy())sss)()(rttyy())sss)(? ?$ 简单计算器描述读入一个只包含 +, -, *, / 的非负整数计算表达式，计算该表达式的值。 输入描述测试输入包含若干测试用例，每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。没有非法表达式。当一行中只有0时输入结束，相应的结果不要输出。 输出描述对每个测试用例输出1行，即该表达式的值，精确到小数点后2位。 输入 1231 + 24 + 2 * 5 - 7 / 110 输出 123.0013.36 测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cctype&gt;using namespace std;stack&lt;char&gt; operation;stack&lt;double&gt; data;int Priority(char c){ if (c == '#') { return 0; } else if (c == '$') { return 1; } else if (c == '+' || c == '-') { return 2; } else { return 3; }}double getNumber(string str, int &amp;index){ double number = 0; while (isdigit(str[index])) { number = number * 10 + str[index] - '0'; index++; } return number;}double Calculate(double x, double y, char op){ double result = 0; if (op == '+') { result = x + y; } else if (op == '-') { result = x - y; } else if (op == '*') { result = x * y; } else if (op == '/') { result = x / y; } return result;}int main(){ string str; while (getline(cin, str)) { if (str == &quot;0&quot;) { break; } int index = 0; str += '$'; //字符串尾部添加$ operation.push('#'); //运算符栈底添加# while (index &lt; str.size()) { if (str[index] == ' ') { index++; } else if (isdigit(str[index])) { data.push(getNumber(str, index)); } else { if (Priority(operation.top()) &lt; Priority(str[index])) { operation.push(str[index]); index++; } else { double y = data.top(); data.pop(); double x = data.top(); data.pop(); data.push(Calculate(x, y, operation.top())); operation.pop(); } } } printf(&quot;%.2f\\n&quot;, data.top()); } return 0;} 123451 + 23.004 + 2 * 5 - 7 / 1113.360 堆栈的使用堆栈是一种基本的数据结构。堆栈具有两种基本操作方式，push 和 pop。其中 push一个值会将其压入栈顶，而 pop则会将栈顶的值弹出。现在我们就来验证一下堆栈的使用。 输入描述对于每组测试数据，第一行是一个正整数 n（0 &lt; n &lt;= 10000）。而后的 n 行，每行的第一个字符可能是'P'或者'O'或者'A'；如果是'P'，后面还会跟着一个整数，表示把这个数据压入堆栈；如果是'O'，表示将栈顶的值 pop出来，如果堆栈中没有元素时，忽略本次操作；如果是'A'，表示询问当前栈顶的值，如果当时栈为空，则输出'E'。堆栈开始为空。 输出描述对于每组测试数据，根据其中的命令字符来处理堆栈；并对所有的'A'操作，输出当时栈顶的值，每个占据一行，如果当时栈为空，则输出'E'。 样例输入 1234567893AP 5A4P 3P 6OA 输出 123E53 测试代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;stack&lt;int&gt; myStack;int main(){ int n; char type; int x; while (scanf(&quot;%d&quot;, &amp;n) != EOF) { if (n == 0) { break; } for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; type; if (type == 'A') { if (myStack.empty()) { cout &lt;&lt; &quot;E&quot; &lt;&lt; endl; } else { cout &lt;&lt; myStack.top() &lt;&lt; endl; } } else if (type == 'P') { cin &gt;&gt; x; myStack.push(x); } else if (type == 'O') { if (!myStack.empty()) { myStack.pop(); } } } } return 0;} 1234567891011123AEP 5A54P 3P 6OA3","link":"/2022/06/04/%E6%A0%88/"},{"title":"队列","text":"简介队列queue是一种线性的序列结构，其存放的元素按照线性的逻辑次序排列，但与一般的线性序列结构如数组或向量相比，队列的操作只限于逻辑上的两端，即新元素只能从队列的一段插入（入队），并且只能从队列的另一端删除已有的元素（出队）。允许队列插入的一端称为队尾，允许队列删除的一端称为队头。 1234567891011121314151617181920212223242526272829303132333435//常规操作#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;using namespace std;queue&lt;int&gt; myQueue;int main(){ printf(&quot;the size of myQueue:%d\\n&quot;, myQueue.size()); for (int i = 0; i &lt; 10; ++i) { myQueue.push(i);//队列元素的添加 } //访问队列中的元素，front(),back() printf(&quot;the front of myQueue:%d\\n&quot;, myQueue.front()); printf(&quot;the back of myQueue:%d\\n&quot;, myQueue.back()); //队列的状态，size(),empty() printf(&quot;the size of myQueue:%d\\n&quot;, myQueue.size()); int sum = 0; while (!myQueue.empty()) { sum += myQueue.front(); myQueue.pop();//队列元素的删除 } printf(&quot;sum:%d\\n&quot;, sum); if (myQueue.empty()) { printf(&quot;myQueue is empty\\n&quot;); } printf(&quot;the size of myQueue:%d\\n&quot;, myQueue.size()); return 0;} 123456the size of myQueue:0the front of myQueue:0the back of myQueue:9the size of myQueue:10sum:45myQueue is emptythe size of myQueue:0 队列的应用约瑟夫问题（变体）n个小孩围成一圈，任意假定一个数m,从第p个小孩起按顺时针方向从1开始报数，当报到m时，该小孩离开然后继续从1开始报数。这样，小孩不断离开，圈子不断缩小直到所有小孩都从圈中出去。请按出去的先后顺序输出小孩的编号。输入n p m，输出小孩的编号序列，用空隔隔开。（用0 0 0结束循环） 样例输入 128 3 40 0 0 样例输出 16,2,7,4,3,5,1,8 测试代码 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;using namespace std;queue&lt;int&gt; children;int main(){ int n, p, m; while (scanf(&quot;%d%d%d&quot;, &amp;n, &amp;p, &amp;m)) { if (n == 0 &amp;&amp; p == 0 &amp;&amp; m == 0) { break; } for (int i = 1; i &lt;= n; ++i) { children.push(i); } for (int i = 1; i &lt; p; ++i) { children.push(children.front()); children.pop(); } while (!children.empty()) { for (int i = 1; i &lt; m; ++i) { children.push(children.front()); children.pop(); } printf(&quot;%d &quot;, children.front()); children.pop(); } printf(&quot;\\n&quot;); } return 0;} 猫狗收容所有家动物收容所只收留猫和狗，但有特殊的收养规则，收养人有两种收养方式：第一种为直接收养所有动物中最早进入收容所的。第二种为选择收养的动物类型(猫或狗)，并收养该种动物中最早进入收容所的。给定一个操作序列代表所有事件。若第一个元素为1，则代表有动物进入收容所。第二个元素为动物的编号，正数代表狗，负数代表猫;若第一个元素为2，则代表有人收养动物，第二个元素若为0，则采取第一种收养方式；若为1，则指定收养狗；若为-1则指定收养猫。请按顺序返回收养的序列。若出现不合法的操作，即没有可以符合领养要求的动物，则将这次领养操作忽略。 输入的第一行第一个数为操作次数n，接下来n行，每行有两个值m和t，分别代表题目中操作的两个元素。 样例输入 123456761 11 -12 01 2 2 -12 1 样例输出 1231 -1 2 测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;struct animal{ int number; //编号 int order; //次序 /*定义了一个与结构体同名的构造函数，因此可以按照构造函数的方法来定义结构animal 例如，animal(2,4)代表了一个动物，并且该动物的编号为2，次序为4*/ animal(int n, int o) : number(n), order(o) {} //构造函数};int main(){ queue&lt;animal&gt; cats; queue&lt;animal&gt; dogs; int n; int order = 0; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; ++i) { int method, type; scanf(&quot;%d%d&quot;, &amp;method, &amp;type); //入 if (method == 1) { if (type &gt; 0) { dogs.push(animal(type, order++)); } else { cats.push(animal(type, order++)); } } //出 else { //猫狗都有 if (type == 0 &amp;&amp; !dogs.empty() &amp;&amp; !cats.empty()) { //狗先 if (dogs.front().order &lt; cats.front().order) { printf(&quot;%d&quot;, dogs.front().number); dogs.pop(); } //猫先 else { printf(&quot;%d&quot;, cats.front().number); cats.pop(); } } //只有猫 else if (type == 0 &amp;&amp; dogs.empty() &amp;&amp; !cats.empty()) { printf(&quot;%d&quot;, cats.front().number); cats.pop(); } //只有狗 else if (type == 0 &amp;&amp; !dogs.empty() &amp;&amp; cats.empty()) { printf(&quot;%d&quot;, dogs.front().number); dogs.pop(); } //只要狗 else if (type == 1 &amp;&amp; !dogs.empty()) { printf(&quot;%d&quot;, dogs.front().number); dogs.pop(); } //只要猫 else if (type == 1 &amp;&amp; !cats.empty()) { printf(&quot;%d&quot;, cats.front().number); cats.pop(); } } } printf(&quot;\\n&quot;); return 0;}","link":"/2022/06/03/%E9%98%9F%E5%88%97/"}],"tags":[{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"树的遍历","slug":"树的遍历","link":"/tags/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"},{"name":"递归解法","slug":"递归解法","link":"/tags/%E9%80%92%E5%BD%92%E8%A7%A3%E6%B3%95/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"非自顶向下","slug":"非自顶向下","link":"/tags/%E9%9D%9E%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/"},{"name":"刷题","slug":"刷题","link":"/tags/%E5%88%B7%E9%A2%98/"},{"name":"CPP","slug":"CPP","link":"/tags/CPP/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"向量","slug":"向量","link":"/tags/%E5%90%91%E9%87%8F/"},{"name":"堆排序","slug":"堆排序","link":"/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"思考","slug":"思考","link":"/tags/%E6%80%9D%E8%80%83/"},{"name":"排序算法","slug":"排序算法","link":"/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"递归求解","slug":"递归求解","link":"/tags/%E9%80%92%E5%BD%92%E6%B1%82%E8%A7%A3/"},{"name":"指针","slug":"指针","link":"/tags/%E6%8C%87%E9%92%88/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"插入排序","slug":"插入排序","link":"/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"},{"name":"希尔排序","slug":"希尔排序","link":"/tags/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"},{"name":"归并排序","slug":"归并排序","link":"/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"快速排序","slug":"快速排序","link":"/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"时间复杂度","slug":"时间复杂度","link":"/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"堆","slug":"堆","link":"/tags/%E5%A0%86/"},{"name":"优先队列","slug":"优先队列","link":"/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","link":"/tags/%E9%98%9F%E5%88%97/"}],"categories":[{"name":"盲人摸象","slug":"盲人摸象","link":"/categories/%E7%9B%B2%E4%BA%BA%E6%91%B8%E8%B1%A1/"},{"name":"北冥有鱼","slug":"北冥有鱼","link":"/categories/%E5%8C%97%E5%86%A5%E6%9C%89%E9%B1%BC/"}]}