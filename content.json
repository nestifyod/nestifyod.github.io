{"pages":[{"title":"Gallery","text":"","link":"/album/index.html"}],"posts":[{"title":"2022.7.16","text":"熟词生义 hazy 朦胧的，困惑的precipitate 加速，使……突然降临，仓促的，草率的hasty 仓促的raw 未经加工的premature 不成熟的，过早的snap 断裂，绷断，啪嗒声，匆忙的，仓促的wire 金属丝，电线，给……拍电报credential 资质，凭证premium 优质的，保险费，奖金，津贴dominant 主导地位intervene 干涉，干预slender 细长的，苗条的，微薄的excursion 远足，旅行spectacle 景观，场面，壮观artistry 艺术性，工艺，艺术效果incorporate 合并，混合stationary 固定的，静止的stationery 文具benchmark 基准，标准spin 旋转，编造utilize 利用，使用notify 通告，通知，公布anticipate 预期，期望，提前使用constitution 宪法，体制，建立，组成versatile 多才多艺的，通用的，万能的类比，推理，类似acquisition 获得，收购parasite 寄生虫calculate 计算，核对，预测calculus 微积分学deteriorate 恶化legitimate 合法的，合理的，正当的esteem 尊重，认为，考虑discipline 惩罚，纪律viable 可行的amend 修整，调整remedy 补救，纠正，治疗depression 沮丧，萧条compression 压缩，浓缩，压迫denote 表示，指示incase 包住，围绕，包装embrace 拥抱，欣然接受，乐意采纳，包括，包含reliance 信心，依赖tuition 学费，讲授tutorial 辅导的，教程surrender 投降，放弃formulate 规划，用公式表示formula 公式standby 备用品diligent 勤奋的，用功的vicious 恶毒的category 种类，分类catalogue 目录inhale 吸入，陈述veteran 老兵，经验丰富的，老练的seasoned 老练的，调好味的，加佐料 核心词汇detour 绕道，迂回junction 连接，交叉点，结合点municipal 市政的，市的mastery 掌握，精通reclaim 改造，开拓，再利用reinforce 加强，巩固，强化warrant 保证，担保，批准，证明primitive 原始的，古老的，原始人propel 推进，激励concise 简洁的，简明的brief 简明的precise 精确的unveil 揭开，揭幕，除去面纱（reveal）proclaim 宣布，宣告，声明（self-proclaimed 自称的）division 除法，部门，分配permutation 置换，组合（方式）reproduction 繁殖rectify 纠正，矫正scatter 分散，散落strew /struː/ 布满，散播在……上 同义替换资质 qualification，credential设施 equipment，facilities，installation，device推进，促进 propel，shove，thrust，promote，boost，accelerate，facilitate，gear up财产 property，asset，estate（real estate 房地产）远足 hike，excursion，trek，tramp（流浪汉）修正 remedy，amend，revise，correct，rectify包含 encase，include，encircle，incase，contain，embody缺陷 flaw，disadvantage，shortage，defect，shortcoming，weakness，drawback，handicap揭示 reveal，unveil，proclaim陈述，声明 statement，proclaim，declaim，announce，affirm，assert，allege，inhale（陈述）复制 copy，replicate，duplicate，reproduce阻碍 obstacle，hinder，block，impediment，handicap，preclude，congestion，cramp复杂的 complex，intricate，sophisticated交换 exchange，interchange，swap，permutation经验丰富的 veteran，practical，experienced，seasoned闲逛 stroll，ramble，rove，roam脆弱的，精致的 fragile，delicate，flimsy（劣质的），vulnerable（有漏洞的）兴旺发达 thrive，prosperous，flourish，boom实干的 pragmatic，do solid work，get right on the job（solving problems in a practical and sensible way rather than by having fixed ideas or theories）本土的 native，indigenous，local，aboriginal幼稚的 naive，childish 看看就好capsule 胶囊，太空舱，压缩的royal 皇家的，女王的，高贵的tar 焦油herb 香草，草药galaxy 银河，星系axis 轴，轴线submarine 海底的，潜水艇foam 泡沫，起泡spiral 螺旋形的，盘旋的helix 螺旋pendulum 钟摆equator 赤道chorus 合唱队，齐声chant 圣歌，唱，颂扬hull 船体，外壳monument 纪念碑pronunciation 发音，读法maritime 海事的，海运的manuscript 手稿，原稿premature 不成熟的，比预期早的astronauts 宇航员astronomy 天文学paradox 悖论，自相矛盾的观点auction 拍卖aesthetic 审美的，美学的distort 扭曲disorder 混乱，紊乱anatomy 解剖学accessory 附件placebo 安慰剂compatible 兼容的comparative 比较的，相当的considerable 相当大的considerate 考虑周到的commodity 日用品interchange 交换，互换statistic 统计的，统计学的embassy 大使馆ambassador 大使replicate 复制的，复制，折叠handicap 残疾，阻碍，生理缺陷coordinate 坐标，调整，协调，同等的elevate 提升，举起liter 升litter 垃圾debris /ˈdebriː/ 残骸，垃圾stroll 漫步，闲逛oriental 东方的，东方人delicate 精致的，脆弱的sophisticated 复杂的，精致的intricate 错综复杂的counterpart 副本，对应的人或物valid 有效的，有根据的，正当的vulnerable 有漏洞的hazel 榛树variant 变体apparatus 仪器property 财产intelligence 智力intelligent 聪明的; 智能的intellectual property 知识产权thrive 繁荣，兴旺prosperity 繁荣昌盛imperative 紧迫的installment 分期付款down payment 首付pragmatic 实干的（get right on the job，do solid work）sensible 明智的，理智的，朴素而实用的meditation 冥想conservatory 音乐学院，(靠房屋一侧用玻璃建造的)温室compatible 兼容的pass 在旁边走过across the bridge 穿过桥coexist 和平共处chronic 长期的chronological 按照时间顺序的overrun 超时proverb 谚语，格言telegraph 电报thermometer 温度计comets 彗星indigenous 本土的premier 首相，首位的premiere 首映，首次公演 口语准备计划PART 1Taking photosDo you like to take photographs? yeah，i am a fan of taking photographs, actually i am an amateur photographer, i enjoy the sense of holding my camera or smart phone on my hand and record the fantastic scenery of animals or landscapes at that moment. Do you ever take photos of yourself? I should say i have taken some photos of myself before, but actually i don’t like this form of photographs though it can record where i am and what i am doing, i prefer to take some landscapes than the people include myself. What is your favorite family photo? Well, let me see, my favorite family photo is the one taken thirteen years ago with my whole family, my parents, my grandparents, my cousin and his parents, and the mother of my grandma who was 95 years old at that time, and that is so memoriable for me because it’s the last family photo of her with her beloved family. Do you want to improve your picture-taking skills? When i am free, i often do some research on how to improve my skills of taking photos, like the choice of shooting angles, camera lens and some other camera settings.And no mater what time it is, if i see something which drive me attention and i am equipped, i will record them as a practise. PART 2名人/普通人Describe an interesting neighbour. You should say: Who the person is How you know this person What he or she does And explain why you think this person is intelligent. The neighbour I find the most interesting is my grandpa. You heard that right he lived the next door to me before and in my opinion, he was a great writer and he wrote the story of himself, he gathered all the experience along the journey to Tibet and some other south-west places of China, formed them into a book, and this work costed him for almost 20 years, he used the computer to write, however this new technic product may be a little bit difficult for an elderly, so when i had my vacation at home, he often asked for help about the layout of the article writing tools like office and the fundmental methods of internet using. He was so persistent on his work including his book after he retired, he was a dedicated person with strong willing, as i helped him with the writing, i fount it interesting to keep on read it, though some other people don’t think so because my grandpa was only a amateur writer exactly, but all of the words he wrote was so true. There is no flowery words, but it really reflects what he saw and heard during the journey and what he learned all his life, geology. I think this is the most precious relic my old neighbour, my dear grandpa leave for me. 来自2022年第二季度口语机经库（05-08月最终版题库和答案）","link":"/2022/07/16/2022-7-16/"},{"title":"2022.7.15","text":"熟词生义 in a close election 在一场势均力敌的选举中defeat the incumbent 击败现任者occupational-disease-inductive accident 职业病引发的事故wax 蜡，蜡制的，给……上蜡seal 密封(容器)，封上(信封)，海豹wax seal 蜡封glow 发光，炽热rather 稍微，有点，相当，宁愿conjunction 连词，连接，联合congestion 拥挤，堵车，人口过剩，稠密burrow 洞穴，地道，探寻，寻找spiral /ˈspaɪrəl/ 螺旋形的，螺旋式地上升（或下降），急剧增长sake 目的，缘由self-proclaimed 自称的perfectionists 完美主义者ironically 讽刺地oriented 朝向，面对，确定方向orientation 方向，目标，定向the Orient 东方drain 排水，流光，放干excrete 排泄county 郡，县dive 潜水，跳水digest 文摘，摘要，消化，吸收obstruct 阻碍，阻塞defer 遵从，听从，顺从，延期drill 训练，钻孔机，钻孔virtue 美德，优点，长处，用处 核心词汇devious /ˈdiːviəs/ 不诚实的，不直率的，欺诈的，迂回的(路线)，曲折的(道路)incumbent /ɪnˈkʌmbənt/ 在职者，现任者，在职的，现任的，有责任，必须履行cylinder /ˈsɪlɪndə/ 圆柱，圆筒状物，气缸compliment 恭维，称赞terminology 术语hurdle 障碍，栏，克服，跳过cease 停止unleash 发动，解除束缚inoculate 接种，嫁接，灌输maverick 获取，背离，行为不合常规的hover 盘旋，翱翔bungalow 平房，小屋helix 螺旋，螺旋状物inflation 通货膨胀screw /skruː/ 螺丝钉，旋紧bald 光秃的，单调的disdain 蔑视，鄙弃miserable 悲惨的，痛苦的wring 拧，绞，痛苦superfluous 多余的，不必要的，奢侈的remanent 剩余的，残余的prescribe 规定，开处方pasture 草地，牧场carbohydrate 碳水化合物buckle 扣住，弯曲，皮带扣mundane 世俗的，宇宙的spectrum 光谱，范围extravagance 奢侈，浪费，过度aggregate 集合，聚集，合计aggravate 使严重，使恶化，激怒rhetoric 花言巧语，华丽辞藻daunting 令人生畏的venerate 敬重，崇敬derive 获得，源自（insect-derived medicine 源自昆虫的药物）deprive 剥夺，剥削secrete 分泌pathogenic 致病的ubiquity 无处不见的peripheral 外围设备，周边的，外围的coefficient 系数，协同因素，共同作用wedge 挤进，楔子consecutive 连续的，连贯的coherent 连贯的consistent 始终如一的，一致的consist 包含amendment 修改，修正案permeate 弥散，渗透penetrate 渗透imperious /ɪmˈpɪəriəs/ 强迫性的imperative /ɪmˈperətɪv/ 重要紧急的，迫切的erratic 不规则的，不稳定的，漂流物rickety 摇晃的（unstable，instable）executive 执行的iterative 迭代的，重复的syndrome 综合症状systematic 系统性的comprehensive 全面的synthetic 合成的，综合的aesthetic 美学的cosmetic 化妆的adorable 可爱的，讨喜的adornment 装饰物instant 瞬间constant 常数，连续的continuous 连续的weary 劳累的exhausted 疲倦的fatigued 劳累的weird 离奇的exterminate 灭绝，毁灭extinction 灭绝profound 深远的compound 混合物（mixture，composite，synthetic stuff 合成材料）blend 搅拌（blender 搅拌机）combination 混合composite /ˈkɒmpəzɪt/ 混合成的，合成物crayon 蜡笔insanity 精神错乱的frantic 着急忙慌的embryo 胚胎，萌芽，初期的consignment 装运的货物，快递，委托，运送terrain 地形，领域dreary 令人沮丧的，沉闷的monotonous /məˈnɒtənəs/ 单调的，单调乏味的homage 敬意hegemony 霸权prefrontal 额前骨，前额的peninsula 半岛synonym 同义词（paraphrase 解释，意译）syllabus 教学大纲（teaching outline）syllable 音节，把……分成音节ambiguity 含糊，模棱两可的话genre /ˈʒɒ̃rə/ 体裁newsreel 新闻短片 同义替换小屋 bungalow，cottage，cabin，lodge，cot，chamber，the burrow螺旋 spiral，helix，screw干扰 interfere，disturb，obstruct，interrupt，bother，intervene延迟 postpone，delay，defer，put off优点 merit，advantage，virtue连续的 constant，consecutive，continuous，consistent强制性的 mandatory， compulsory，imperious，imperative激增 proliferate，surge，soar，increase sharply骤降 slump，plummet疲惫的 tired，exhausted，weary，worn out，fatigued古怪的 weird，eccentric，odd，strange，bizarre破坏 destruct，devastate，exterminate，ruin，destroy遭遇 confront，encounter，face with，come across，run into，bump into对付 cope with，deal with，tackle不稳定的 unstable，rickety，instable，erratic， fluctuate领域 domain，realm，field沉闷的，单调的 monotonous，dreary，dull，boring，plain（平淡无奇的）解释 explain，expound，explicate，interpret 看看就好binocular 望远镜drought 干旱的biology 生物学bargain 讨价还价transaction 交易trade 交易，贸易corporation 公司mathematics 数学algorithm 算法dawn 黎明previous 以前的precious 珍贵的boil 煮沸soil 土壤spoil 破坏，溺爱bend 弯曲（sharply bend 急转弯）author 作者authorize 授权authentic 真正的，可信的authorization 批准，授权书poem 诗人poetry 诗歌verse 韵文，诗，诗节poverty 贫穷theory 理论therapy 疗法irritated 恼怒地irrigation 灌溉seethe 强压怒火，翻腾sooth 真正的，抚慰的，光滑的throat 咽喉，嗓子（sore throat 嗓子疼）pump 水泵sow 播种seed 种子degrade 降级，退化burst 爆发，突发furniture 家具otherwise 否则recognize 识别，分析cheque 支票bulletin /ˈbʊlətɪn/ 公报，公布（announcement）cope 处理，应付（cope with）reluctant 不情愿的redundant 冗余的political 政治的citizen 公民，市民confident 自信的demolish 拆除designated 指定的electricity 电力，电流contain 包含，容纳retain 保持，保留protein 蛋白质valuable 有价值的vulnerable 有漏洞的experiment 实验attempt 尝试，企图，努力situation 情况（case，condition，circumstances）context 上下文，环境，语境occasion 场合bulb 电灯泡geography 地理，地形（geographic 地理学的）cautious 谨慎的，小心的particular 特比的，详尽的calorie 卡路里accent 口音ancient 古代的convenient 方便的nowhere 无处leisure 闲暇，娱乐assumption 猜想consumption 消耗ripe 熟的，成熟的raw 生的mature 成熟的suppose 假设，认为，猜想barely 仅仅，几乎不merely 仅仅handbook 手册，指南relic 遗产，遗留物legacy 遗产plain 平原，平淡无奇plaint 起诉，诉状complain 抱怨explain 解释endeavor 努力recap 简要回顾，概括 阅读刷题计划剑15阅读题题型分布 LOH 5% 选择题 14%（单选 + 多选） 匹配题 18% 判断题 19% 填空题 44% 单选题 顺序原则 一题一段 选项较长 易定位，难解题 怎么选？ 有无事实依据（细节题，一句话阐述，类似于句子匹配题） 作者意图（概括题，例子之前，类似于LOH题） 全文主旨（取标题，假大空，类似于TFNG题） 三种方法 常识判断 逻辑判断，e.g. 矛盾二选一，顾名思义，不止英语题中遇到过，e.g. LOH 在文章之前出现的题 有1~2个例子 考察段落主旨 选项&gt;段落 首先在list of headings中划去做为例子的headings，以免在根据段落内容在list of headings中找出与其相匹配的段落标题时，它(它们)会干扰考试者对其他headings的选择。 在文章中把做为例子的段落划掉，以免对例子段落进行不必要的精读。 对题目中给出的段落，按照首句(第一、二句)、末句和中间句寻找主题句的方法，在list of headings中找出与其相匹配的段落标题。 剑14 Test 2 Passage 3，今晚这篇LOH做的很是不爽。 段落匹配题 剑14 Test 3 Passage 2，都对了，不过速度成问题，并且别盲目自信，这只是passage 2。","link":"/2022/07/15/2022-7-15/"},{"title":"二叉树的下一个结点","text":"题目给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 分析二叉树的下一个节点，一共有以下情况： 二叉树为空，则返回空； 节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点； 节点不是根节点。如果该节点是其父节点的左孩子，则返回父节点；否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果。 12345678910111213141516171819202122232425262728/*struct TreeLinkNode { int val; struct TreeLinkNode *left; struct TreeLinkNode *right; struct TreeLinkNode *next; //父节点 TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) { }};*/class Solution {public: TreeLinkNode* GetNext(TreeLinkNode* pNode) { if(pNode-&gt;right) { //如果有右子树，则找右子树的最左节点 TreeLinkNode *p = pNode-&gt;right; while(p-&gt;left) p = p-&gt;left; return p; } TreeLinkNode *p = pNode; while(p-&gt;next) { //没右子树，则找第一个当前节点是父节点左孩子的节点 if(p-&gt;next-&gt;left == p) return p-&gt;next; p = p-&gt;next; } return nullptr; //退到了根节点仍没找到，则返回null }}; 复习 前序遍历：F, B, A, D, C, E, G, I, H中序遍历：A, B, C, D, E, F, G, H, I后序遍历：A, C, E, D, B, H, I, G, F层次遍历：F, B, G, A, D, I, C, E, H","link":"/2022/07/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9/"},{"title":"二叉树中的最大路径和","text":"题目路径被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中至多出现一次。该路径至少包含一个节点，且不一定经过根节点。 路径和 是路径中各节点值的总和。 给你一个二叉树的根节点 root ，返回其 最大路径和 。 输入：root = [-10,9,20,null,null,15,7]输出：42解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42 递归林小鹿 路径 在这道题目中，路径是指从树中某个节点开始，沿着树中的边走，走到某个节点为止，路过的所有节点的集合。路径的权值和是指路径中所有节点的权值的总和。 对于一棵树，我们可以将其划分为很多的子树，如下图所示，虚线矩形围起来的子树。我们把这颗子树的蓝色节点称为该子树最高节点。用最高节点可以将整条路径分为两部分：从该节点向左子树延伸的路径，和从该节点向右子树延伸的部分。 递归遍历整棵树，递归时维护从每个子树从最高节点开始往下延伸的最大路径和。 对于每个子树的最高节点，递归计算完左右子树后，我们将左右子树维护的两条最大路径，和该点拼接起来，就可以得到以这个点为最高节点子树的最大路径。（这条路径一定是：左子树路径-&gt;最高节点-&gt;右子树路径） 然后维护从这个点往下延伸的最大路径：从左右子树的路径中选择权值大的一条延伸即可。（只能从左右子树之间选一条路径） 最后整颗树的最大路径和为: 根节点值+左子树最大路径和+右子树最大路径和，即left_max + right_max + root-&gt;val 注意 如果某条路径之和小于0，那么我们选择不走该条路径，因此其路径之和应和0之间取最大值。 时间复杂度分析: 每个节点仅会遍历一次，所以时间复杂度是 O(n)。 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: int res = INT_MIN; int maxPathSum(TreeNode* root) { dfs(root); return res; } int dfs(TreeNode* root){ if(!root) return 0; int left = max(0, dfs(root-&gt;left)), right = max(0, dfs(root-&gt;right)); res = max(res, root-&gt;val + left + right); return root-&gt;val + max(left, right); }}; DFS-非自顶而下作者：eh-xing-qing总结得实在好 非自顶而下 这类题目一般解题思路如下：设计一个辅助函数maxpath，调用自身求出以一个节点为根节点的左侧最长路径left和右侧最长路径right，那么经过该节点的最长路径就是left+right接着只需要从根节点开始dfs，不断比较更新全局变量即可 12345678910int res=0;int maxPath(TreeNode *root) //以root为路径起始点的最长路径{ if (!root) return 0; int left=maxPath(root-&gt;left); int right=maxPath(root-&gt;right); res = max(res, left + right + root-&gt;val); //更新全局变量 return max(left, right); //返回左右路径较长者} 这类题型DFS注意点 left,right代表的含义要根据题目所求设置，比如最长路径、最大路径和等等 全局变量res的初值设置是0还是INT_MIN要看题目节点是否存在负值,如果存在就用INT_MIN，否则就是0 注意两点之间路径为1，因此一个点是不能构成路径的 1234567891011121314151617181920class Solution{public: int res = INT_MIN; //注意节点值可能为负数，因此要设置为最小值 int maxPathSum(TreeNode *root) { maxPath(root); return res; } int maxPath(TreeNode *root) //以root为路径起始点的最长路径 { if (!root) return 0; int left = max(maxPath(root-&gt;left), 0); int right = max(maxPath(root-&gt;right), 0); res = max(res, left + right + root-&gt;val); //比较当前最大路径和与左右子树最长路径加上根节点值的较大值，更新全局变量 return max(left + root-&gt;val, right + root-&gt;val); //返回左右子树较长的路径加上根节点值 }};","link":"/2022/07/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"},{"title":"二叉树的最近公共祖先","text":"题目给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出：3解释：节点 5 和节点 1 的最近公共祖先是节点 3 。 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出：5解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。 输入：root = [1,2], p = 1, q = 2输出：1 好笨啊，看看题解吧 递归Moment 当我们用递归去做这个题时不要被题目误导，应该要明确一点这个函数的功能有三个：给定两个节点 p 和 q 如果 p 和 q 都存在，则返回它们的公共祖先； 如果只存在一个，则返回存在的一个； 如果 p 和 q 都不存在，则返回NULL 本题说给定的两个节点都存在，那自然还是能用上面的函数来解决 具体思路 如果当前结点 root 等于 NULL，则直接返回 NULL 如果 root 等于 p 或者 q ，那这棵树一定返回 p 或者 q 然后递归左右子树，因为是递归，使用函数后可认为左右子树已经算出结果，用 left 和 right 表示 此时若left为空，那最终结果只要看 right；若 right 为空，那最终结果只要看 left 如果 left 和 right 都非空，因为只给了 p 和 q 两个结点，都非空，说明一边一个，因此 root 是他们的最近公共祖先 如果 left 和 right 都为空，则返回空（其实已经包含在前面的情况中了） 时间复杂度是 O(n)：每个结点最多遍历一次或用主定理，空间复杂度是 O(n)：需要系统栈空间 123456789101112131415161718192021class Solution {public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(root == NULL) return NULL; if(root == p || root == q) return root; TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q); if(left == NULL) return right; if(right == NULL) return left; if(left &amp;&amp; right) // p和q在两侧 return root; return NULL; // 必须有返回值 }}; 暴力old8 一次dfs维护出每个点的深度和父亲，查询时先将两点定到相同深度，之后一起往上跳。整体复杂度为O(nlogn)。 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { map&lt;TreeNode*, int&gt; vis; map&lt;TreeNode*, TreeNode*&gt; pre; function&lt;void(TreeNode*, TreeNode*, int)&gt; dfs = [&amp;](TreeNode* fa, TreeNode* rt, int dep) { vis[rt] = dep; pre[rt] = fa; if (rt-&gt;left) dfs(rt, rt-&gt;left, dep + 1); if (rt-&gt;right) dfs(rt, rt-&gt;right, dep + 1); }; dfs(NULL, root, 1); if (p == q) return p; while (vis[p] &gt; vis[q] &amp;&amp; pre[p] != NULL) p = pre[p]; while (vis[p] &lt; vis[q] &amp;&amp; pre[q] != NULL) q = pre[q]; while (p != q) { p = pre[p]; q = pre[q]; } return p; }}; 倍增优化DP维护f(u, k)表示u节点的第$2^k$个祖先，更新时一次dfs，f(u, k + 1) = f(f(u, k), k)，查询的时候类似暴力解法，不过向上跳可以跳得步伐大很多。对于本题预处理复杂度为O(nlogn)，查询复杂度为O(2logn)。 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { const int maxf = 22; map&lt;TreeNode*, int&gt; vis; map&lt;TreeNode*, TreeNode*&gt; pre[maxf]; function&lt;void(TreeNode*, TreeNode*, int)&gt; dfs = [&amp;](TreeNode* fa, TreeNode* rt, int dep) { vis[rt] = dep; pre[0][rt] = fa; for (int i = 0; (1 &lt;&lt; i) &lt;= vis[fa] &amp;&amp; i &lt; maxf; i++) { pre[i + 1][rt] = pre[i][pre[i][rt]]; } if (rt-&gt;left) dfs(rt, rt-&gt;left, dep + 1); if (rt-&gt;right) dfs(rt, rt-&gt;right, dep + 1); }; dfs(NULL, root, 1); if (vis[p] &lt; vis[q]) swap(p, q); for (int i = maxf - 1; i &gt;= 0; i--) { if (vis[p] &gt;= (1 &lt;&lt; i) &amp;&amp; vis[pre[i][p]] &gt;= vis[q]) p = pre[i][p]; if (p == q) return p; } for (int i = maxf - 1; i &gt;= 0; i--) { if (vis[p] &gt;= (1 &lt;&lt; i) &amp;&amp; pre[i][p] != pre[i][q]) { p = pre[i][p]; q = pre[i][q]; } } return pre[0][p]; }}; 思考Krahets 何为最近公共祖先？ 设节点 root 为节点 p，q 的某公共祖先，若其左子节点 root.left 和右子节点 root.right 都不是 p，q的公共祖先，则称 root 是“最近的公共祖先” 根据以上定义，若 root 是 p，q 的最近最近公共祖先，则只可能为以下的情况之一： p，q 位于 root 异侧（分别在左右子树中） p = root，且 q 在 root 的左或右子树中 q = root，且 p 在 root 的左或右子树中 比如，上图中的7，8，它们的最近公共祖先为3，因为5不是8的祖先，1不为7的祖先。 递归解析 终止条件 当越过叶节点，直接返回null； 当root等于p，q，则直接返回root； 递归工作 开启递归左子节点，返回值记为left； 开启递归右子节点，返回值即为right； 返回值： 当left和right同为空，说明root的左/右子树中均不含p，q，则返回null； 当left和right同不为空，说明p，q分别位于root异侧，因此root为最近公共祖先，返回root； 当left为空，right不为空，p，q都不在root的左子树中，直接返回right，具体有两种情况： p，q其中一个在root的右子树中，此时right指向p（假设为p）； p，q两节点都在root的右子树中，此时的right指向最近公共祖先节点； 当left不为空，right为空，与前一种情况同理 12345678910111213141516171819202122232425class Solution {public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(root == nullptr || root == p || root == q) return root; TreeNode *left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode *right = lowestCommonAncestor(root-&gt;right, p, q); if(left == nullptr &amp;&amp; right == nullptr) return nullptr; // 1. if(left == nullptr) return right; // 3. if(right == nullptr) return left; // 4. return root; // 2. if(left != null and right != null) }};/*观察发现， 情况 1. 可合并至 3. 和 4. 内*/// class Solution {// public:// TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {// if(root == nullptr || root == p || root == q) return root;// TreeNode *left = lowestCommonAncestor(root-&gt;left, p, q);// TreeNode *right = lowestCommonAncestor(root-&gt;right, p, q);// if(left == nullptr) return right;// if(right == nullptr) return left;// return root;// }// }; 时间复杂度 O(N) ： 其中 NN 为二叉树节点数；最差情况下，需要递归遍历树的所有节点。 空间复杂度 O(N) ： 最差情况下，递归深度达到 N ，系统使用 O(N) 大小的额外空间。","link":"/2022/07/14/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"},{"title":"一些有趣的题目","text":"充实的寒假生活(GREEDY/DP)描述 寒假马上就要到了，龙傲天同学获得了从第0天开始到第60天结束为期61天超长寒假，他想要尽可能丰富自己的寒假生活。现提供若干个活动的起止时间，请计算龙同学这个寒假至多可以参加多少个活动？注意所参加的活动不能有任何时间上的重叠，在第x天结束的活动和在第x天开始的活动不可同时选择。 输入 第一行为整数n，代表接下来输入的活动个数(n &lt; 10000)紧接着的n行，每一行都有两个整数，第一个整数代表活动的开始时间，第二个整数代表全结束时间 输出 输出至多参加的活动个数 样例输入 12345650 01 12 23 34 4 样例输出 15 解决 1234567891011121314151617181920212223242526class Solution(object): def eraseOverlapIntervals(self, intervals): &quot;&quot;&quot; :type intervals: List[List[int]] :rtype: int &quot;&quot;&quot; if not intervals or len(intervals) == 0: return 0 intervals.sort(key = lambda x: x[0]) # 按左端点从小到大排序 temp_pos = 0 cnt = 0 for i in range(1, len(intervals)): if intervals[temp_pos][1] &gt;= intervals[i][0]: # 当当前区间右端点&gt;i区间左端点 if intervals[i][1] &lt; intervals[temp_pos][1]: # 当i区间右端点&lt;当前区间右端点，表示i区间被覆盖在当前区间中 temp_pos = i # 更新temp_pos，选择覆盖范围小的i区间 cnt += 1 # 当前区间右端点&gt;i区间左端点都要计数+1 else: temp_pos = i # 当当前区间右端点&lt;=i区间左端点，表示不重叠，要更新temp_pos return len(intervals)-cntif __name__ == &quot;__main__&quot;: n=int(input()) intervals=[] for i in range(n): intervals.append(list(map(int, input().split()))) print(Solution().eraseOverlapIntervals(intervals)) 和为给定数描述 给出若干个整数，询问其中是否有一对数的和等于给定的数。 输入 共三行：第一行是整数n(0 &lt; n &lt;= 100,000)，表示有n个整数。第二行是n个整数。整数的范围是在0到108之间。第三行是一个整数m（0 &lt;= m &lt;= 230)，表示需要得到的和。 输出 若存在和为m的数对，输出两个整数，小的在前，大的在后，中间用单个空格隔开。若有多个数对满足条件，选择数对中较小的数更小的。若找不到符合要求的数对，输出一行No。 样例输入 12342 5 1 46 样例输出 11 5 解决 123456789101112131415161718192021222324252627def find(key,base,top): #二分查找 while base&lt;=top: mid = (base+top)//2 if a[mid]==key: return True elif a[mid]&lt;key: base=mid+1 else: top=mid-1 return False n=int(input())a=list(map(int,input().split()))a=sorted(a)flag=0# print(a)m=int(input())for i in range(n): key=m-a[i] base=i+1 top=n-1 if find(key,base,top): print(a[i],key) flag=1 breakif flag==0: print(&quot;No&quot;) 求逆序对数描述 对于一个长度为N的整数序列A，满足i &lt; j且 Ai &gt; Aj.的数对(i,j)称为整数序列A的一个逆序请求出整数序列A的所有逆序对个数 输入 输入包含多组测试数据，每组测试数据有两行第一行为整数N(1 &lt;= N &lt;= 20000)，当输入0时结束第二行为N个整数，表示长为N的整数序列 输出 每组数据对应一行，输出逆序对的个数 样例输入 123456751 2 3 4 555 4 3 2 1110 样例输出 1230100 解决1 冒泡，可能会超时 1234567891011121314151617def main(): while True: n = int(input()) if n==0: return ll = list(map(int, input().split())) # print(ll) c=[0 for i in range(101)] group=0 for i in range(n-1): for j in range(i,n-1): if ll[j]&gt;ll[j+1]: group+=1 print(group)if __name__ == '__main__': main() 解决2 归并 1234567891011121314151617181920212223242526272829303132333435363738def merge_sort(a): s = 0 if len(a) &lt;= 1: return 0 mid = len(a) // 2 l = a[:mid] r = a[mid:] s += merge_sort(l) + merge_sort(r) i = j = k = 0 while (i &lt; len(l) and j &lt; len(r)): if (l[i] &lt;= r[j]): a[k] = l[i] i += 1 k += 1 else: a[k] = r[j] j += 1 k += 1 s += len(l) - i while (i &lt; len(l)): a[k] = l[i] i += 1 k += 1 while (j &lt; len(r)): a[k] = r[j] j += 1 k += 1 return sdef main(): while True: n = int(input()) if n==0: return ll = list(map(int, input().split())) print(merge_sort(ll))if __name__ == '__main__': main() 小木棍描述 小明将一批等长的木棍随机切成最长为50单位的小段。现在他想要将木棍还原成原来的状态，但是却忘记了原来的木棍数量和长度。请写一个程序帮助他计算如果还原成原来的等长木棍，其长度可能的最小值。所有的长度均大于0。 输入 输入包含多个实例。每个实例有两行，第一行是切割后的木棍数量n（最多64个），第二行为n个以空格分开的整数，分别为每根木棍的长度。输入的最后以n为 0 结束。 输出 对于每个实例，输出一行其长度的可能的最小值。 样例输入 1234595 2 1 5 2 1 5 2 141 2 3 40 样例输出 1265 来源 来自计算概论B期末考试，本题对数据进行了弱化 解决 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647N=105a=[0 for _ in range(N)]v=[0 for _ in range(N)]target=0n=0maxn=0def dfs(cnt, len, pos): if cnt == target: return True #拼够了根数，符合题意 if len == maxn: return dfs(cnt+1, 0, 0) #拼完了一根 继续下一根 i = pos while i&lt;n: if v[i]==0 and len+a[i]&lt;=maxn: v[i]=1 if dfs(cnt, len+a[i], i): return True v[i]=0 if len == 0: return False #凑第一根的时候可以随便选，如果随便选都凑不成一根，那这个长度不行 神奇剪枝！！ while i+1&lt;n and a[i+1]==a[i]: i += 1 #如果用当前的小木段拼凑 失败则与它等长的同样失败，小剪枝 i += 1 return Falsewhile True: n=int(input()) if n==0: break arr = input() a = [0 for _ in range(N)] a = [int(n) for n in arr.split()] asum = 0 asum = sum(a) a=sorted(a,reverse=True) maxn = 0 maxn=a[0] while maxn &lt;= asum: if asum%maxn == 0: target = asum / maxn v = [0 for _ in range(N)] if dfs(0, 0, 0): break maxn += 1 print(maxn) 修仙之路描述 修仙之路长漫漫，逆水行舟，不进则退！你过五关斩六将，终于来到了仙界。仙界是一个r行c列的二维格子空间，每个单元格是一个”境界“，每个境界都有等级。你需要任意选择其中一个境界作为起点，从一个境界可以前往上下左右相邻四个境界之一 ，当且仅当新到达的境界等级增加。你苦苦行走，直到所在的境界等级比相邻四个境界的等级都要高为止，一览众山小。请问包括起始境界在内最长修仙路径需要经过的境界数是多少？ 输入 第一行为两个正整数，分别为r和c（1&lt;=r,c&lt;=100）。接下来有r行，每行有c个0到100000000之间的整数，代表各境界的等级。 输出 输出一行，为最长修仙路径需要经过的境界数（包括起始境界）。 样例输入 1234565 51 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9 样例输出 125 解决1 没有考虑位于边界的“仙境” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import java.util.Scanner;/**] * * 5 5 * 1 2 3 4 5 * 16 17 18 19 6 * 15 24 25 20 7 * 14 23 22 21 8 * 13 12 11 10 9 * * */public class Main { public static void main(String[] args) { Scanner sc =new Scanner(System.in); int m= sc.nextInt(); int n =sc.nextInt(); int [][] nums = new int[m][n]; for(int i=0;i&lt;m;i++){ for(int j = 0;j&lt;n;j++){ nums[i][j] = sc.nextInt(); } } /* int [][] dp = new int[m][n]; dp[0][0] =1; int target =0; // i+1,j // i-1,j // i,j+1// i,j-1 for(int i=0;i&lt;m;i++){ for(int j=0;j&lt;n;j++){ if(i==0&amp;&amp;j==0){ continue; } if(i+1&lt;m&amp;&amp;j&lt;n &amp;&amp; nums[i+1][j]&lt;nums[i][j]){ dp [i][j] =Math.max(dp[i+1][j],dp[i][j])+1; } if (0&lt;=i-1&amp;&amp;j&lt;n&amp;&amp; nums[i-1][j]&lt;nums[i][j]){ dp [i][j] =Math.max(dp[i-1][j],dp[i][j])+1; } if(i&lt;m&amp;&amp;j+1&lt;n &amp;&amp; nums[i][j+1]&lt;nums[i][j]){ dp [i][j] =Math.max(dp[i][j+1],dp[i][j])+1; } if(i&lt;m&amp;&amp;j-1&gt;=0 &amp;&amp; nums[i][j-1]&lt;nums[i][j]){ dp [i][j] =Math.max(dp[i][j-1],dp[i][j])+1; } int tmp = nums[i][j]; int tmp1 = dp[i][j]; target = Math.max(dp[i][j],target); } } System.out.println(target);*/ int a = dfs(nums,0,0,m,n,1); System.out.println(a); } public static int dfs(int [][] nums ,int i,int j ,int m, int n ,int tt ){ if(i&lt;0 || i&gt;m || j&lt;0||j&gt;n){ return 0; } if(is(nums,i,j,m,n)==4){ return tt; } int a =0; int b=0; int c=0; int d=0; if(i-1&gt;=0&amp;&amp;nums[i][j]&lt;nums[i-1][j]){ a= dfs(nums, i-1, j, m, n,tt+1); } if(i+1&lt;m&amp;&amp;nums[i][j]&lt;nums[i+1][j]){ b= dfs(nums, i+1, j, m, n,tt+1); } if(j-1&gt;=0&amp;&amp;nums[i][j]&lt;nums[i][j-1]){ c= dfs(nums, i, j-1, m, n,tt+1); } if(j+1&lt;n&amp;&amp;nums[i][j]&lt;nums[i][j+1]){ d= dfs(nums, i, j+1, m, n,tt+1); } a= Math.max(a,b); a= Math.max(a,c); a= Math.max(a,d); return a; } public static int is(int [][] nums,int i,int j,int m,int n){ int tar=0; if(i-1&gt;=0){ if( nums[i][j]&gt;nums[i-1][j]){ tar++; } } if(i+1&lt;m){ if( nums[i][j]&gt;nums[i+1][j]){ tar++; } } if(j-1&gt;=0){ if( nums[i][j]&gt;nums[i][j-1]){ tar++; } } if(j+1&lt;n){ if( nums[i][j]&gt;nums[i][j+1]){ tar++; } } return tar; }} 来自啊鱼咕嘟 解决2 12345678910111213141516171819202122232425262728# 5 5# 1 2 3 4 5# 16 17 18 19 6# 15 24 25 20 7# 14 23 22 21 8# 13 12 11 10 9n,m=map(int,input().split())nums = []for _ in range(n): nums.append(list(map(int, input().split())))dp=[[-1]* m for _ in range(n)]move=[[0,1],[1,0],[-1,0],[0,-1]]def dfs(i,j): if dp[i][j]!=-1: return dp[i][j] ret=1 for oi,oj in move: ni,nj=i+oi,j+oj if 0&lt;=ni&lt;n and 0&lt;=nj&lt;m and nums[i][j]&gt;nums[ni][nj]: ret=max(ret,dfs(ni,nj)+1) dp[i][j]=ret return dp[i][j]res=0for i in range(n): for j in range(m): res=max(res,dfs(i,j))print(res) 拦截导弹描述 某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。 输入导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数），计算这套系统最多能拦截多少导弹。 输入 第一行是一个整数N（不超过15），表示导弹数。第二行包含N个整数，为导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数）。 输出 一个整数，表示最多能拦截的导弹数。 样例输入 128389 207 155 300 299 170 158 65 样例输出 16 解决 123456789101112131415161718i=0data = [0 for _ in range(100)]ans = [0 for _ in range(100)]n=int(input())arr=input()data = [int(n) for n in arr.split()]ans[0] = 1maxt = 1for j in range(1, n): ans[j] = 1 for i in range(0, j): if data[i]&gt;=data[j]: if ans[i]+1&gt; ans[j]: ans[j] = ans[i]+1 if ans[j]&gt; maxt: maxt = ans[j]print(maxt) 采药（DP）描述 辰辰是个很有潜能、天资聪颖的孩子，他的梦想是称为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。” 如果你是辰辰，你能完成这个任务吗？ 输入 输入的第一行有两个整数T（1 &lt;= T &lt;= 1000）和M（1 &lt;= M &lt;= 100），T代表总共能够用来采药的时间，M代表山洞里的草药的数目。接下来的M行每行包括两个在1到100之间（包括1和100）的的整数，分别表示采摘某株草药的时间和这株草药的价值。 输出 输出只包括一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。 样例输入 123470 371 10069 11 2 样例输出 13 来源 NOIP 2005 解决 123456789N=1010T,M=map(int,input().split())f = [0 for _ in range(N)]for i in range(0, M): v,w=map(int,input().split()) for j in range(T, v - 1, -1): f[j] = max(f[j], f[j - v] + w)print(f[T]) 简单的整数划分问题描述 将正整数n 表示成一系列正整数之和，n=n1+n2+…+nk, 其中n1&gt;=n2&gt;=…&gt;=nk&gt;=1 ，k&gt;=1 。正整数n 的这种表示称为正整数n 的划分。正整数n 的不同的划分个数称为正整数n 的划分数。 输入 标准的输入包含若干组测试数据。每组测试数据是一个整数N(0 &lt; N &lt;= 50)。 输出 对于每组测试数据，输出N的划分数。 样例输入 15 样例输出 17 提示 5, 4+1, 3+2, 3+1+1, 2+2+1, 2+1+1+1, 1+1+1+1+1 解决 1234567891011121314151617def f(x,y): if y == 1: return 1 elif y &lt;= 0: return 0 elif x &lt; y: return 0 else: return(f(x - 1,y - 1) + f(x - y,y))while True: try: n = int(input()) s = 1 for i in range(n): s = s + f(n,i) print(s) except EOFError: break","link":"/2022/03/20/%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A2%98%E7%9B%AE/"},{"title":"反转链表","text":"题目给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 输入：head = [1,2,3,4,5]输出：[5,4,3,2,1] 递归路漫漫我不畏 使用递归函数，一直递归到链表的最后一个结点，该结点就是反转后的头结点，记作 cur 此后，每次函数在返回的过程中，让当前结点的下一个结点的 next 指针指向当前节点 同时让当前结点的 next 指针指向 NULL ，从而实现从链表尾部开始的局部反转 当递归函数全部出栈后，链表反转完成 123456789101112131415class Solution{public: ListNode *reverseList(ListNode *head) { if (head == NULL || head-&gt;next == NULL) { return head; } ListNode *cur = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return cur; }}; 简单的双指针 定义双指针：pre 和 cur 局部反转：pre-&gt;next=cur pre 和 cur 同时右移一个位置 循环上述过程，直至 pre 到达链表尾部 12345678910111213141516class Solution{public: ListNode *reverseList(ListNode *head) { ListNode *cur = NULL, *pre = head; while (pre != NULL) { ListNode *tmp = pre-&gt;next; pre-&gt;next = cur; cur = pre; pre = tmp; } return cur; }}; 较复杂的双指针 定义指针 cur ，初始化为 head 局部反转：head-&gt;next 的 next 指向 cur cur 和 head-&gt;next 同时右移一个位置 循环上述过程，直至 cur 到达链表尾部 1234567891011121314151617181920class Solution{public: ListNode *reverseList(ListNode *head) { if (head == NULL) { return NULL; } ListNode *cur = head; while (head-&gt;next != NULL) { ListNode *t = head-&gt;next-&gt;next; head-&gt;next-&gt;next = cur; cur = head-&gt;next; head-&gt;next = t; } return cur; }};","link":"/2022/07/11/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"title":"向量","text":"简介向量vector是可以改变其大小的线性序列容器，像数组一样，向量使用连续的空间存储元素，这表明向量可以像数组一样通过下标来访问其元素，但不同于数组的是，向量的大小可以动态变化。 12345678910111213141516171819202122232425262728293031323334//常用操作#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;using namespace std;vector&lt;int&gt; myVector;int main(){ for (int i = 0; i &lt; 5; ++i) { myVector.push_back(i); //从尾部逐一添加元素 } myVector.insert(myVector.begin(), 3, 15); //头部插入3个15 myVector.pop_back(); for (int i = 0; i &lt; myVector.size(); ++i) { printf(&quot;%d &quot;, myVector[i]); } printf(&quot;\\n&quot;); printf(&quot;the 5th element of myVector:%d\\n&quot;, myVector[4]); printf(&quot;the size of myVector:%d\\n&quot;, myVector.size()); myVector.erase(myVector.begin() + 5, myVector.end()); //删除第5后续的元素 vector&lt;int&gt;::iterator it; //定义迭代器 for (it = myVector.begin(); it != myVector.end(); it++) { printf(&quot;%d &quot;, *it); //遍历向量 } printf(&quot;\\n&quot;); myVector.clear(); return 0;} 123415 15 15 0 1 2 3the 5th element of myVector:1the size of myVector:715 15 15 0 1 向量的应用完数与盈数一个数如果恰好等于它的各因子(该数本身除外)之和，如：6=3+2+1。则称其为“完数”；若因子之和大于该数，则称其为“盈数”。 求出2到60之间所有“完数”和“盈数”。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;using namespace std;vector&lt;int&gt; numberE; //完数vector&lt;int&gt; numberG; //盈数int Sum(int x){ int sum = 0; for (int i = 1; i &lt; x; ++i) { if (x % i == 0) { sum += i; } } return sum;}int main(){ for (int i = 2; i &lt;= 60; ++i) { if (i == Sum(i)) { numberE.push_back(i); } else if (i &lt; Sum(i)) { numberG.push_back(i); } } printf(&quot;E:&quot;); for (int i = 0; i &lt; numberE.size(); ++i) { printf(&quot;%d &quot;, numberE[i]); } printf(&quot;\\n&quot;); printf(&quot;G:&quot;); for (int i = 0; i &lt; numberG.size(); ++i) { printf(&quot;%d &quot;, numberG[i]); } printf(&quot;\\n&quot;); return 0;} 12E:6 28G:12 18 20 24 30 36 40 42 48 54 56 60","link":"/2022/06/03/%E5%90%91%E9%87%8F/"},{"title":"堆排序","text":"什么是堆如果有一个关键码的集合K={k_0,k_1,k_2,…,k_{n-1}}，把它的所有元素按完全二叉树的顺序存储方式存储在一个一维数组中，并满足ki&lt;=k_{2i+1}且ki&lt;=k_{2i+2}（或满足ki&gt;=k_{2i+1}且ki&gt;=k_{2i+2}），其中i=0,1,2,…则称该集合为堆。 小堆：对于一棵完全二叉树，满足任一节点都比其孩子节点小，也就是将根结点为最小元素的堆叫做小堆，也叫最小堆或小根堆。 大堆：对于一棵完全二叉树，满足任一节点都比其孩子节点大，也就是将根结点为最大元素的堆叫做大堆，也叫最大堆或大根堆。 堆的性质 堆中某个结点的值总是不大于或不小于其父结点的值。 堆总是一棵完全二叉树。 堆的向下调整假设：节点的左右子树都是堆（大/小），但是其自身不是堆，可以通过一次向下的调整来将其变换成一个堆。以调整至大堆为例 从根结点处开始，选出左右孩子中值较大的孩子。 让较大的孩子与其父亲进行比较。 若较大的孩子比父亲大，则该孩子与其父亲的位置进行交换。并将原来小的孩子的位置当成父亲继续向下进行调整，直到调整到叶子结点为止。 若较大的孩子比父亲小，则不需处理了，调整完成，整个树已经是大堆了。12345678910111213141516171819202122def sift(li,low,high): ''' :param li:列表 :param low:堆的根节点位置 :param high:堆的最后一个元素的位置 :return: ''' i = low #父节点 j=2*i+1 #左孩子 tmp=li[low] #堆顶存储 while j&lt;=high: #只要左孩子没越界 if j+1&lt;=high and li[j+1]&gt;li[j]: #如果有右孩子,并且右孩子比较大,别忘了前提需要保证j+1位置不越界 j=j+1 #j指向右孩子位置 if li[j]&gt;tmp: li[i]=li[j] i=j #往下看一层 j=2*i+1 else: #如果tmp更大,把tmp放到i的位置上 li[i]=tmp break else: #别忘了考虑,如果当堆顶元素的左孩子已经越界,直接将其存入li[i] li[i]=tmp 全过程 建立堆，得到堆顶元素，为最大元素12345678910111213141516171819202122232425262728293031323334def sift(li,low,high): ''' :param li:列表 :param low:堆的根节点位置 :param high:堆的最后一个元素的位置 :return: ''' i = low #父节点 j=2*i+1 #左孩子 tmp=li[low] #堆顶存储 while j&lt;=high: #只要左孩子没越界 if j+1&lt;=high and li[j+1]&gt;li[j]: #如果有右孩子,并且右孩子比较大,别忘了还要保证j+1位置不越界 j=j+1 #j指向右孩子位置 if li[j]&gt;tmp: li[i]=li[j] i=j #往下看一层 j=2*i+1 else: # 不管怎么样都得把这个空补上，直接脱到最后执行 break li[i]=tmpdef heapCreate(li): n=len(li) for i in range((n-2)//2,-1,-1): #i表示建堆的时候调整的部分根下标 sift(li,i,n-1) #堆建立完成# 验证import randomli=[i for i in range(16)]random.shuffle(li)print(li)heapCreate(li)print(li) 12[9, 13, 15, 6, 14, 8, 12, 7, 11, 1, 2, 3, 4, 10, 5, 0][15, 14, 12, 11, 13, 8, 10, 7, 6, 1, 2, 3, 4, 9, 5, 0] 去掉堆顶，将堆最后一个元素放到堆顶，实质上交换了堆顶元素和堆尾元素，但是需要注意交换后的堆尾元素并不是原来的堆顶元素，而应当是原堆尾元素的左边紧挨着的那一个元素，所以接下来的调整传入的堆尾索引也就是high为i-1，接着可通过一次调整重新使得堆有序 堆顶元素为第二大元素 重复步骤2，直到堆空12345678910111213141516171819202122232425262728293031323334353637def sift(li,low,high): ''' :param li:列表 :param low:堆的根节点位置 :param high:堆的最后一个元素的位置 :return: ''' i = low #父节点 j=2*i+1 #左孩子 tmp=li[low] #堆顶存储 while j&lt;=high: #只要左孩子没越界 if j+1&lt;=high and li[j+1]&gt;li[j]: #如果有右孩子,并且右孩子比较大,别忘了还要保证j+1位置不越界 j=j+1 #j指向右孩子位置 if li[j]&gt;tmp: li[i]=li[j] i=j #往下看一层 j=2*i+1 else: # 不管怎么样都得把这个空补上，直接脱到最后执行 break li[i]=tmpdef heapSort(li): n=len(li) for i in range((n-2)//2,-1,-1): #i表示建堆的时候调整的部分根下标 sift(li,i,n-1) #堆建立完成 for i in range(n-1,-1,-1): #i指向当前堆的最后一个元素 li[0],li[i]=li[i],li[0] #先交换堆顶元素和堆尾元素 sift(li,0,i-1) #i-1为新的high# 验证import randomli=[i for i in range(16)]random.shuffle(li)print(li)heapSort(li)print(li) 12[7, 5, 11, 12, 14, 0, 15, 4, 13, 9, 6, 8, 10, 2, 1, 3][0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] 时间复杂度分为两部分，第一部分向下调整 1234567891011121314def sift(li,low,high): i = low j=2*i+1 tmp=li[low] while j&lt;=high: if j+1&lt;=high and li[j+1]&gt;li[j]: j=j+1 if li[j]&gt;tmp: li[i]=li[j] i=j j=2*i+1 else: break li[i]=tmp 这一部分，相当于走了一遍完全二叉树的深度，设元素个数为n，深度即为log(n+1) 相当于logn （根据深度为h，结点数最多为2^h-1） 12345678def heapSort(li): n=len(li) for i in range((n-2)//2,-1,-1): sift(li,i,n-1) #堆建立完成 for i in range(n-1,-1,-1): li[0],li[i]=li[i],li[0] sift(li,0,i-1) 第二部分为建堆，逐个出数，外层循环部分均为$n$，而内层为调整函数，所以总的时间复杂度为$O(nlogn)$ C++版本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;void max_heapify(vector&lt;int&gt;&amp; nums, int start, int end){ int dad = start; int son = dad * 2 + 1; while (son &lt;= end) { if (son + 1 &lt;= end &amp;&amp; nums[son] &lt; nums[son + 1]) { son++; } if (nums[dad] &gt; nums[son]) { return; } else { swap(nums[dad], nums[son]); dad = son; son = dad * 2 + 1; } }}void heap_sort(vector&lt;int&gt;&amp; nums, int len){ for (int i = len / 2 - 1; i &gt;= 0; i--) { max_heapify(nums, i, len - 1); } for (int i = len - 1; i &gt; 0; i--) { swap(nums[0], nums[i]); max_heapify(nums, 0, i - 1); }}int main() { int num; vector&lt;int&gt; int_array; while (cin &gt;&gt; num) { int_array.push_back(num); if (cin.get() == '\\n')break; } int len = int_array.size(); heap_sort(int_array, len); for (int n : int_array)cout &lt;&lt; n &lt;&lt; &quot; &quot;; return 0;} topk问题现在有n个数，设计算法得到前k大的数（k&lt;n） 解决思路 排序后切片 O(nlogn) 冒泡、插入、选择排序 O(kn) 堆排序 O(klogn) 取列表前k个元素建立一个小根堆，堆顶就是目前第k大的数；依次向后遍历原列表，对于列表中的元素，如果小于堆顶，则忽略该元素；如果大于堆顶，则将堆顶更换为该元素，并且对堆进行一次调整；遍历列表所有元素后，倒序弹出堆顶。 比如 6 8 1 9 3 0 7 2 4 5 拿出前五个数，建立一个小根堆 剩下 0 7 2 4 5 0&lt;1 0舍 1不动 剩下 7 2 4 5 7&gt;1 1舍 7上 剩下 2 4 5 7&gt;3 小根堆调整 7、3对调 剩下 2 4 5 2&lt;3 2舍 3不动 剩下4 5 4&gt;3 3舍 4上 剩下5 5&gt;4 4舍5上 具体怎么做？基本就是小根堆版本 12345678910111213141516171819202122232425262728293031323334353637383940def sift(li,low,high): ''' :param li:列表 :param low:堆的根节点位置 :param high:堆的最后一个元素的位置 :return: ''' i = low #父节点 j=2*i+1 #左孩子 tmp=li[low] #堆顶存储 while j&lt;=high: #只要左孩子没越界 if j+1&lt;=high and li[j+1]&lt;li[j]: #如果有右孩子,并且右孩子比较小,别忘了还要保证j+1位置不越界 j=j+1 #j指向右孩子位置 if li[j]&lt;tmp: li[i]=li[j] i=j #往下看一层 j=2*i+1 else: # 不管怎么样都得把这个空补上，直接脱到最后执行 break li[i]=tmpdef topk(li,k): heap=li[0:k] #取前k个数 for i in range((k-2)//2,-1,-1): sift(heap,i,k-1) #1.小根堆建立完成 for i in range(k,len(li)): if li[i]&gt;heap[0]: heap[0]=li[i] sift(heap,0,k-1) #2.遍历列表里剩下的所有元素完成 for i in range(k-1,-1,-1): #i指向当前堆的最后一个元素 heap[0],heap[i]=heap[i],heap[0] #先交换堆顶元素和堆尾元素 sift(heap,0,i-1) #i-1为新的high #3.挨个出数完成 return heapli=[6,8,1,9,3,0,7,2,4,5]print(li)print(topk(li,5))","link":"/2022/05/14/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"title":"希尔排序","text":"回顾插入排序 12345678def insertSort(li): for i in range(1,len(li)): #i表示摸到的牌的下标,注意循环从1开始,因为手里的牌是0 tmp=li[i] j=i-1 #j表示手里的牌的下标 while j&gt;=0 and li[j]&gt;tmp: #如果手里的牌比tmp小或者手里已经没有牌了,结束循环 li[j+1]=li[j] j-=1 li[j+1]=tmp 希尔排序现在，希尔排序在插入排序的基础上，设置了间隔gap，实现了分组插入排序 首先取一个整数d1=n/2，将元素分为d1个组，每组相邻两元素之间间距为d1，在个组内进行直接插入排序 取第二个整数d2=d1/2，重复上述分组排序过程，直到di=1，即所有元素在同一组内进行直接插入排序 希尔排序每趟并不能使某些元素有序，而是使整体数据越来越接近有序；最有一趟使得所有数据有序。 1234567891011121314151617181920212223def insertSort_gap(li,gap): for i in range(gap,len(li)): #i表示摸到的牌的下标,注意循环从gap开始,因为手里的牌是0~(gap-1) tmp=li[i] j=i-gap #j表示手里的牌的下标 while j&gt;=0 and li[j]&gt;tmp: #如果手里的牌比tmp小或者手里已经没有牌了,结束循环 li[j+gap]=li[j] j-=gap li[j+gap]=tmpdef shell_sort(li): d=len(li)//2 while d&gt;=1: insertSort_gap(li,d) d//=2# 验证import randomli=list(range(10))random.shuffle(li)print(li)shell_sort(li)print(li) 12[1, 9, 8, 5, 2, 0, 4, 6, 7, 3][0, 1, 2, 3, 4, 5, 6, 7, 8, 9]","link":"/2022/05/12/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"},{"title":"归并排序","text":"基本思路一次归并 假设左右部分都已经排好序 123456789101112131415161718192021222324def merge(li,low,mid,high): i=low j=mid+1 tmp=[] while i&lt;=mid and j&lt;=high: if li[i]&lt;li[j]: tmp.append(li[i]) i+=1 else: tmp.append(li[j]) j+=1 while i&lt;=mid: tmp.append(li[i]) i+=1 while j&lt;=high: tmp.append(li[j]) j+=1 li[low:high+1]=tmp# 验证li=[2,4,6,8,1,3,5,7]print(li)merge(li,0,3,7)print(li) 12[2, 4, 6, 8, 1, 3, 5, 7][1, 2, 3, 4, 5, 6, 7, 8] 先分解 将列表越分越小，直至分成一个元素，使用递归 剩下合并其实就是上面的一次归并 12345678910111213141516171819202122232425262728293031323334def merge(li,low,mid,high): i=low j=mid+1 tmp=[] while i&lt;=mid and j&lt;=high: if li[i]&lt;li[j]: tmp.append(li[i]) i+=1 else: tmp.append(li[j]) j+=1 while i&lt;=mid: tmp.append(li[i]) i+=1 while j&lt;=high: tmp.append(li[j]) j+=1 li[low:high+1]=tmpdef merge_sort(li,low,high): if low&lt;high: #至少两个元素,递归 mid=(low+high)//2 merge_sort(li,low,mid) merge_sort(li,mid+1,high) merge(li,low,mid,high)# 验证import randomli=list(range(16))random.shuffle(li)print(li)merge_sort(li,0,len(li)-1)print(li) 12[14, 3, 5, 11, 6, 9, 8, 7, 4, 15, 0, 12, 1, 10, 13, 2][0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] 为了更加直观地看到分解以及合并的递归过程，我们对merge_sort()函数稍作修改 1234567def merge_sort(li,low,high): if low&lt;high: #至少两个元素,递归 mid=(low+high)//2 merge_sort(li,low,mid) merge_sort(li,mid+1,high) print(li[low:high+1]) merge(li,low,mid,high) 1234567891011121314151617[10, 9, 8, 13, 14, 4, 1, 2, 7, 6, 15, 5, 11, 0, 3, 12][10, 9][8, 13][9, 10, 8, 13][14, 4][1, 2][4, 14, 1, 2][8, 9, 10, 13, 1, 2, 4, 14][7, 6][15, 5][6, 7, 5, 15][11, 0][3, 12][0, 11, 3, 12][5, 6, 7, 15, 0, 3, 11, 12][1, 2, 4, 8, 9, 10, 13, 14, 0, 3, 5, 6, 7, 11, 12, 15][0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] C++1234567891011121314151617181920212223242526272829303132333435363738394041#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; t;void mergesort(vector&lt;int&gt;&amp; a, int low, int high) { if (low &gt;= high) return; int mid = (low + high) &gt;&gt; 1; mergesort(a, low, mid); mergesort(a, mid + 1, high); int i = low, j = mid + 1, idx = low; while (i &lt;= mid || j &lt;= high) { if (i &lt;= mid &amp;&amp; j &lt;= high) { if (a[i] &lt;= a[j]) t[idx] = a[i++]; else t[idx] = a[j++]; } else if (i &lt;= mid) { t[idx] = a[i++]; } else { t[idx] = a[j++]; } idx++; } for (int k = low; k &lt;= high; k++) a[k] = t[k];}int main() { int num; vector&lt;int&gt; a; while (cin &gt;&gt; num) { a.push_back(num); if (cin.get() == '\\n')break; } t.resize(a.size()); mergesort(a, 0, a.size() - 1); for (int n : a)cout &lt;&lt; n &lt;&lt; &quot; &quot;; return 0;} 时间复杂度从图入手，每一层相当于把整个列表遍历一遍，O(n)；总共logn层，所以合并也就是一半部分的时间复杂度为O(nlogn)。 还有因为归并排序不是”原地排序”，我们开了一个临时空间tmp，所以空间复杂度为O(n)。","link":"/2022/05/15/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"title":"数组中的第K个最大元素","text":"题目给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 输入：[3,2,3,1,2,4,5,5,6] 和 k = 4输出：4 暴力求解1234567891011121314#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution {public: int findKthLargest(vector&lt;int&gt; &amp;nums, int k) { int size = nums.size(); sort(begin(nums), end(nums)); return nums[size - k]; }}; 大顶堆调用priority_queue 12345678910111213class Solution{public: int findKthLargest(vector&lt;int&gt; &amp;nums, int k) { priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; maxHeap; for (int x : nums) maxHeap.push(x); for (int _ = 0; _ &lt; k - 1; _++) maxHeap.pop(); return maxHeap.top(); }}; NB solution 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution{public: void shiftDown(vector&lt;int&gt; &amp;nums, int i, int len) { int root = i; while (root &lt; len) { int tmp = root; int left = 2 * root + 1, right = 2 * root + 2; if (left &lt; len &amp;&amp; nums[root] &lt; nums[left]) { root = left; } if (right &lt; len &amp;&amp; nums[root] &lt; nums[right]) { root = right; } if (root == tmp) { break; } swap(nums[tmp], nums[root]); } } void buildHeap(vector&lt;int&gt; &amp;nums) { int n = nums.size(); for (int i = n / 2 - 1; i &gt;= 0; i--) { shiftDown(nums, i, n); } } int findKthLargest(vector&lt;int&gt; &amp;nums, int k) { //构建最大堆 buildHeap(nums); int n = nums.size(); // pop k-1个元素 for (int i = n - 1; i &gt; n - k; i--) { swap(nums[0], nums[i]); shiftDown(nums, 0, i); } return nums[0]; }}; 优先队列其内部可以看作是一棵由数组模拟的完全二叉树，对于这棵树的每一个结点来说，自身的优先级不低于左右孩子的优先级，所以其功能就是拿出优先级最大的元素，如何简单使用C++中内置容器priority_queue？首先引出头文件&lt;queue&gt;，定义一个默认的优先队列（大顶堆）priority_queue&lt;int&gt; que;即值越大的元素优先级越高先出队。 que.size() 元素数量 que.push(x) 插入x que.pop() 删除优先级最高的元素 que.top() 访问优先级最高的元素（堆顶元素） que.empty() 判空 对于优先队列的操作，插入删除的时间复杂度为对数级，访问堆顶元素时间复杂度为常数级，所以比较适合动态调整，获得极值。 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;//大顶堆int main(){ priority_queue&lt;int&gt; que; que.push(7); que.push(5); que.push(-2); que.push(1); que.push(6); cout &lt;&lt; que.size() &lt;&lt; endl; while (!que.empty()) { cout &lt;&lt; que.top() &lt;&lt; &quot; &quot;; que.pop(); } cout &lt;&lt; endl; return 0;} 如何定义一个小顶堆？优先队列除了第一个数据类型以外，还有其他两个模板参数：底层顺序结构类型（默认是vector，也可使用queue或者array），第三个参数是一个仿函数，提供优先队列权值比较方法。 12priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; q; //大顶堆priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; //小顶堆 其中greater&lt;int&gt;和less&lt;int&gt;即为仿函数，其中greater的实现如下 12345678template &lt;class T&gt;struct greater : public binary_function&lt;T, T, bool&gt;{ bool operator()(const T &amp;x, const T &amp;y) const { return x &gt; y; }} 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;//小顶堆int main(){ priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; que; que.push(7); que.push(5); que.push(-2); que.push(1); que.push(6); cout &lt;&lt; que.size() &lt;&lt; endl; while (!que.empty()) { cout &lt;&lt; que.top() &lt;&lt; &quot; &quot;; que.pop(); } cout &lt;&lt; endl; return 0;} 定义一个自定义类型的优先队列 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct node{ int x, y; //重载运算符，重载小于号，若需小根堆，this-&gt;x &gt; b.x 即可 bool operator&lt;(const node &amp;b) const { return this-&gt;x &lt; b.x; }};int main(){ priority_queue&lt;node&gt; que; que.push((node){1, 5}); que.push((node){2, 3}); que.push((node){9, 4}); que.push((node){-5, 5}); while (!que.empty()) { cout &lt;&lt; que.top().x &lt;&lt; endl; que.pop(); } return 0;} 12345[root@VM-12-16-centos lab]# ./a.out 921-5","link":"/2022/07/10/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"},{"title":"快速排序","text":"基于分治的思想，首先在数组中选择一个基准点，选取基准点的效率决定了时间复杂度，从数组两端扫描数组，设置low 和 high两个索引，图中蓝标代表low红标代表high，橘色表代表重合位置 首次分割，数列被分成了两个子数列，长度分别是i-1和n-i，排序时间表示为T(i-1)和T(n-i)，计算总时间还得加上分割操作的时间，分割操作只用了循环while(low&lt;high)，此段时间记为cn，所以Tn = T(i-1)+T(n-i)+cn； 演示1234567891011121314151617181920212223242526272829303132333435363738394041424344public class quicksort { public static void main(String[] args) { int[] arr = { 23, 46, 0, 8, 11, 18 }; quickSort(arr, 0, arr.length - 1); System.out.print(&quot;排序后 &quot;); for (int i : arr) { System.out.print(i+&quot; &quot;); } } private static void quickSort(int[] arr, int low, int high) { if (low &lt; high) { // 找寻基准数据的正确索引 int index = getIndex(arr, low, high); // 进行迭代对index之前和之后的数组进行相同的操作使整个数组变成有序 //quickSort(arr, 0, index - 1); 之前的版本，这种姿势有很大的性能问题，谢谢大家的建议 quickSort(arr, low, index - 1); quickSort(arr, index + 1, high); } } private static int getIndex(int[] arr, int low, int high) { // 基准数据 int tmp = arr[low]; while (low &lt; high) { // 当队尾的元素大于等于基准数据时,向前挪动high指针 while (low &lt; high &amp;&amp; arr[high] &gt;= tmp) { high--; } // 如果队尾元素小于tmp了,需要将其赋值给low arr[low] = arr[high]; // 当队首元素小于等于tmp时,向前挪动low指针 while (low &lt; high &amp;&amp; arr[low] &lt;= tmp) { low++; } // 当队首元素大于tmp时,需要将其赋值给high arr[high] = arr[low]; } // 跳出循环时low和high相等,此时的low或high就是tmp的正确索引位置 // 由原理部分可以很清楚的知道low位置的值并不是tmp,所以需要将tmp赋值给arr[low] arr[low] = tmp; return low; // 返回tmp的正确位置 }} 最坏的情况数列每次分割得到的两个子数列长度为n-1和0，也就是其中的每一个元素都要移动n次，总时间T(n^2) 123456789101112T(n) = T(n - 1) + C*n T(n - 1) = T(n - 2) + C*(n - 1) # 将 n 减 1，得到下个子序列T(n - 2) = T(n - 3) + C*(n - 3)....T(2) = T(1) + C*2T(1) = T(0) + C# 将下一级表达式代入上一级T(n) = T(0) + C*n + C*(n-1) + C*(n-2) + C*(n-3).....+C*(2)+C# T(0)是等于0的T(n) = C*n + C*(n-1) + C*(n-2) + C*(n-3).....+C*(2)+CT(n) = C*[n + (n-1) + (n-2) + (n-3).....+2+1]T(n) = C*(n + 1)*n/2 最高阶为n^2，最差时间复杂度为O(n^2) 最好情况数列每次分割得到的两个子数列长度等长，除分割时间以外左右各为T(n/2)，总时间2T(n/2)+cn 12345678910T(n) = 2T(n / 2) + C*n T(n / 2) = 2T(n / 4) + C*n / 2 T(n / 4) = 2T(n / 8) + C*n / 4 ....# 将下一级表达式代入上一级，化简找到通项T(n) = 2^k*T（n/2^k）+ kcn# 当n/2^k-&gt;1， k = lg2nT(n) = nT(1) + cnlg2n 最优时间复杂度为O(nlgn) 平均时间复杂度 &lt;&lt;算法导论&gt;&gt; p98 p99","link":"/2021/10/01/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"title":"栈","text":"简介和队列一样，栈stack也是一种线性序列结构，其存放的元素也是按照线性逻辑次序排列的，然而，与一般的线性结构相比，栈的操作仅限于逻辑上特定的一端，即新元素只能从栈的一端插入，也只能从这一端删除已有的元素。栈中允许元素插入和删除的一端称为栈顶，禁止操作的盲端称为栈底。于是，插入元素和删除元素就分别成为入栈和出栈。 12345678910111213141516171819202122232425262728293031//常规操作#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;cstdio&gt;using namespace std;stack&lt;int&gt; myStack;int main(){ printf(&quot;the size of myStack:%d\\n&quot;, myStack.size()); for (int i = 0; i &lt; 10; ++i) { myStack.push(i); } printf(&quot;the top of myStack:%d\\n&quot;, myStack.top()); printf(&quot;the size of myStack:%d\\n&quot;, myStack.size()); int sum = 0; while (!myStack.empty()) { sum += myStack.top(); myStack.pop(); } printf(&quot;sum:%d\\n&quot;, sum); if (myStack.empty()) { printf(&quot;myStack is empty&quot;); } return 0;} 12345the size of myStack:0the top of myStack:9the size of myStack:10sum:45myStack is empty 栈的应用逆序输出You are given a sequence of integer numbers. Zero-complexity transposition of the sequence is the reverse of this sequence. Your task is to write a program that prints zero-complexity transposition of the given sequence. 输入描述For each case, the first line of the input file contains one integer n-length of the sequence (0 ＜ n ≤ 10 000). The second line contains n integers numbers-a1, a2, …, an (-1 000 000 000 000 000 ≤ ai ≤ 1 000 000 000 000 000). 输出描述For each case, on the first line of the output file print the sequence in the reverse order. 输入 125-3 4 6 -8 9 输出 19 -8 6 4 -3 测试代码 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;cstdio&gt;using namespace std;stack&lt;long long&gt; reverse;int main(){ int num; while (scanf(&quot;%d&quot;, &amp;num) != EOF) { while (num--) { long long number; scanf(&quot;%lld&quot;, &amp;number); reverse.push(number); } while (!reverse.empty()) { printf(&quot;%lld &quot;, reverse.top()); reverse.pop(); } printf(&quot;\\n&quot;); } return 0;} 1235-3 4 6 -8 99 -8 6 4 -3 括号匹配问题输出包括两行，第一行输出原始输入字符，第二行由$ ?和空格组成，$ ?分别代表与之对应的左括号和右括号无法匹配。 样例输入 1)(rttyy())sss)( 输出 12)(rttyy())sss)(? ?$ 测试代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;stack&lt;int&gt; brackets;int main(){ string str; while (cin &gt;&gt; str) { string answer(str.size(), ' '); //设定为输入空格个长度 for (int i = 0; i &lt; str.size(); ++i) { if (str[i] == '(') { brackets.push(i); //压入左括号的下标 } else if (str[i] == ')') { if (!brackets.empty()) { brackets.pop(); } else { answer[i] = '?'; //右括号不匹配 } } } while (!brackets.empty()) { answer[brackets.top()] = '$'; brackets.pop(); } cout &lt;&lt; str &lt;&lt; endl; cout &lt;&lt; answer &lt;&lt; endl; } return 0;} 123)(rttyy())sss)()(rttyy())sss)(? ?$ 简单计算器描述读入一个只包含 +, -, *, / 的非负整数计算表达式，计算该表达式的值。 输入描述测试输入包含若干测试用例，每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。没有非法表达式。当一行中只有0时输入结束，相应的结果不要输出。 输出描述对每个测试用例输出1行，即该表达式的值，精确到小数点后2位。 输入 1231 + 24 + 2 * 5 - 7 / 110 输出 123.0013.36 测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cctype&gt;using namespace std;stack&lt;char&gt; operation;stack&lt;double&gt; data;int Priority(char c){ if (c == '#') { return 0; } else if (c == '$') { return 1; } else if (c == '+' || c == '-') { return 2; } else { return 3; }}double getNumber(string str, int &amp;index){ double number = 0; while (isdigit(str[index])) { number = number * 10 + str[index] - '0'; index++; } return number;}double Calculate(double x, double y, char op){ double result = 0; if (op == '+') { result = x + y; } else if (op == '-') { result = x - y; } else if (op == '*') { result = x * y; } else if (op == '/') { result = x / y; } return result;}int main(){ string str; while (getline(cin, str)) { if (str == &quot;0&quot;) { break; } int index = 0; str += '$'; //字符串尾部添加$ operation.push('#'); //运算符栈底添加# while (index &lt; str.size()) { if (str[index] == ' ') { index++; } else if (isdigit(str[index])) { data.push(getNumber(str, index)); } else { if (Priority(operation.top()) &lt; Priority(str[index])) { operation.push(str[index]); index++; } else { double y = data.top(); data.pop(); double x = data.top(); data.pop(); data.push(Calculate(x, y, operation.top())); operation.pop(); } } } printf(&quot;%.2f\\n&quot;, data.top()); } return 0;} 123451 + 23.004 + 2 * 5 - 7 / 1113.360 堆栈的使用堆栈是一种基本的数据结构。堆栈具有两种基本操作方式，push 和 pop。其中 push一个值会将其压入栈顶，而 pop则会将栈顶的值弹出。现在我们就来验证一下堆栈的使用。 输入描述对于每组测试数据，第一行是一个正整数 n（0 &lt; n &lt;= 10000）。而后的 n 行，每行的第一个字符可能是'P'或者'O'或者'A'；如果是'P'，后面还会跟着一个整数，表示把这个数据压入堆栈；如果是'O'，表示将栈顶的值 pop出来，如果堆栈中没有元素时，忽略本次操作；如果是'A'，表示询问当前栈顶的值，如果当时栈为空，则输出'E'。堆栈开始为空。 输出描述对于每组测试数据，根据其中的命令字符来处理堆栈；并对所有的'A'操作，输出当时栈顶的值，每个占据一行，如果当时栈为空，则输出'E'。 样例输入 1234567893AP 5A4P 3P 6OA 输出 123E53 测试代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;stack&lt;int&gt; myStack;int main(){ int n; char type; int x; while (scanf(&quot;%d&quot;, &amp;n) != EOF) { if (n == 0) { break; } for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; type; if (type == 'A') { if (myStack.empty()) { cout &lt;&lt; &quot;E&quot; &lt;&lt; endl; } else { cout &lt;&lt; myStack.top() &lt;&lt; endl; } } else if (type == 'P') { cin &gt;&gt; x; myStack.push(x); } else if (type == 'O') { if (!myStack.empty()) { myStack.pop(); } } } } return 0;} 1234567891011123AEP 5A54P 3P 6OA3","link":"/2022/06/04/%E6%A0%88/"},{"title":"队列","text":"简介队列queue是一种线性的序列结构，其存放的元素按照线性的逻辑次序排列，但与一般的线性序列结构如数组或向量相比，队列的操作只限于逻辑上的两端，即新元素只能从队列的一段插入（入队），并且只能从队列的另一端删除已有的元素（出队）。允许队列插入的一端称为队尾，允许队列删除的一端称为队头。 1234567891011121314151617181920212223242526272829303132333435//常规操作#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;using namespace std;queue&lt;int&gt; myQueue;int main(){ printf(&quot;the size of myQueue:%d\\n&quot;, myQueue.size()); for (int i = 0; i &lt; 10; ++i) { myQueue.push(i);//队列元素的添加 } //访问队列中的元素，front(),back() printf(&quot;the front of myQueue:%d\\n&quot;, myQueue.front()); printf(&quot;the back of myQueue:%d\\n&quot;, myQueue.back()); //队列的状态，size(),empty() printf(&quot;the size of myQueue:%d\\n&quot;, myQueue.size()); int sum = 0; while (!myQueue.empty()) { sum += myQueue.front(); myQueue.pop();//队列元素的删除 } printf(&quot;sum:%d\\n&quot;, sum); if (myQueue.empty()) { printf(&quot;myQueue is empty\\n&quot;); } printf(&quot;the size of myQueue:%d\\n&quot;, myQueue.size()); return 0;} 123456the size of myQueue:0the front of myQueue:0the back of myQueue:9the size of myQueue:10sum:45myQueue is emptythe size of myQueue:0 队列的应用约瑟夫问题（变体）n个小孩围成一圈，任意假定一个数m,从第p个小孩起按顺时针方向从1开始报数，当报到m时，该小孩离开然后继续从1开始报数。这样，小孩不断离开，圈子不断缩小直到所有小孩都从圈中出去。请按出去的先后顺序输出小孩的编号。输入n p m，输出小孩的编号序列，用空隔隔开。（用0 0 0结束循环） 样例输入 128 3 40 0 0 样例输出 16,2,7,4,3,5,1,8 测试代码 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;using namespace std;queue&lt;int&gt; children;int main(){ int n, p, m; while (scanf(&quot;%d%d%d&quot;, &amp;n, &amp;p, &amp;m)) { if (n == 0 &amp;&amp; p == 0 &amp;&amp; m == 0) { break; } for (int i = 1; i &lt;= n; ++i) { children.push(i); } for (int i = 1; i &lt; p; ++i) { children.push(children.front()); children.pop(); } while (!children.empty()) { for (int i = 1; i &lt; m; ++i) { children.push(children.front()); children.pop(); } printf(&quot;%d &quot;, children.front()); children.pop(); } printf(&quot;\\n&quot;); } return 0;} 猫狗收容所有家动物收容所只收留猫和狗，但有特殊的收养规则，收养人有两种收养方式：第一种为直接收养所有动物中最早进入收容所的。第二种为选择收养的动物类型(猫或狗)，并收养该种动物中最早进入收容所的。给定一个操作序列代表所有事件。若第一个元素为1，则代表有动物进入收容所。第二个元素为动物的编号，正数代表狗，负数代表猫;若第一个元素为2，则代表有人收养动物，第二个元素若为0，则采取第一种收养方式；若为1，则指定收养狗；若为-1则指定收养猫。请按顺序返回收养的序列。若出现不合法的操作，即没有可以符合领养要求的动物，则将这次领养操作忽略。 输入的第一行第一个数为操作次数n，接下来n行，每行有两个值m和t，分别代表题目中操作的两个元素。 样例输入 123456761 11 -12 01 2 2 -12 1 样例输出 1231 -1 2 测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;struct animal{ int number; //编号 int order; //次序 /*定义了一个与结构体同名的构造函数，因此可以按照构造函数的方法来定义结构animal 例如，animal(2,4)代表了一个动物，并且该动物的编号为2，次序为4*/ animal(int n, int o) : number(n), order(o) {} //构造函数};int main(){ queue&lt;animal&gt; cats; queue&lt;animal&gt; dogs; int n; int order = 0; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; ++i) { int method, type; scanf(&quot;%d%d&quot;, &amp;method, &amp;type); //入 if (method == 1) { if (type &gt; 0) { dogs.push(animal(type, order++)); } else { cats.push(animal(type, order++)); } } //出 else { //猫狗都有 if (type == 0 &amp;&amp; !dogs.empty() &amp;&amp; !cats.empty()) { //狗先 if (dogs.front().order &lt; cats.front().order) { printf(&quot;%d&quot;, dogs.front().number); dogs.pop(); } //猫先 else { printf(&quot;%d&quot;, cats.front().number); cats.pop(); } } //只有猫 else if (type == 0 &amp;&amp; dogs.empty() &amp;&amp; !cats.empty()) { printf(&quot;%d&quot;, cats.front().number); cats.pop(); } //只有狗 else if (type == 0 &amp;&amp; !dogs.empty() &amp;&amp; cats.empty()) { printf(&quot;%d&quot;, dogs.front().number); dogs.pop(); } //只要狗 else if (type == 1 &amp;&amp; !dogs.empty()) { printf(&quot;%d&quot;, dogs.front().number); dogs.pop(); } //只要猫 else if (type == 1 &amp;&amp; !cats.empty()) { printf(&quot;%d&quot;, cats.front().number); cats.pop(); } } } printf(&quot;\\n&quot;); return 0;}","link":"/2022/06/03/%E9%98%9F%E5%88%97/"}],"tags":[{"name":"IELTS","slug":"IELTS","link":"/tags/IELTS/"},{"name":"熟词生义","slug":"熟词生义","link":"/tags/%E7%86%9F%E8%AF%8D%E7%94%9F%E4%B9%89/"},{"name":"核心词汇","slug":"核心词汇","link":"/tags/%E6%A0%B8%E5%BF%83%E8%AF%8D%E6%B1%87/"},{"name":"同义替换","slug":"同义替换","link":"/tags/%E5%90%8C%E4%B9%89%E6%9B%BF%E6%8D%A2/"},{"name":"看看就好","slug":"看看就好","link":"/tags/%E7%9C%8B%E7%9C%8B%E5%B0%B1%E5%A5%BD/"},{"name":"口语准备计划","slug":"口语准备计划","link":"/tags/%E5%8F%A3%E8%AF%AD%E5%87%86%E5%A4%87%E8%AE%A1%E5%88%92/"},{"name":"阅读刷题计划","slug":"阅读刷题计划","link":"/tags/%E9%98%85%E8%AF%BB%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"刷题","slug":"刷题","link":"/tags/%E5%88%B7%E9%A2%98/"},{"name":"CPP","slug":"CPP","link":"/tags/CPP/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树的遍历","slug":"树的遍历","link":"/tags/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"},{"name":"递归解法","slug":"递归解法","link":"/tags/%E9%80%92%E5%BD%92%E8%A7%A3%E6%B3%95/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"非自顶向下","slug":"非自顶向下","link":"/tags/%E9%9D%9E%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/"},{"name":"时间复杂度","slug":"时间复杂度","link":"/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"name":"思考","slug":"思考","link":"/tags/%E6%80%9D%E8%80%83/"},{"name":"完备的推理","slug":"完备的推理","link":"/tags/%E5%AE%8C%E5%A4%87%E7%9A%84%E6%8E%A8%E7%90%86/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"冒泡","slug":"冒泡","link":"/tags/%E5%86%92%E6%B3%A1/"},{"name":"排序算法","slug":"排序算法","link":"/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"递归求解","slug":"递归求解","link":"/tags/%E9%80%92%E5%BD%92%E6%B1%82%E8%A7%A3/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"指针","slug":"指针","link":"/tags/%E6%8C%87%E9%92%88/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"向量","slug":"向量","link":"/tags/%E5%90%91%E9%87%8F/"},{"name":"堆排序","slug":"堆排序","link":"/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"name":"插入排序","slug":"插入排序","link":"/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"},{"name":"希尔排序","slug":"希尔排序","link":"/tags/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"},{"name":"归并排序","slug":"归并排序","link":"/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"堆","slug":"堆","link":"/tags/%E5%A0%86/"},{"name":"优先队列","slug":"优先队列","link":"/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"快速排序","slug":"快速排序","link":"/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","link":"/tags/%E9%98%9F%E5%88%97/"},{"name":"暴力","slug":"暴力","link":"/tags/%E6%9A%B4%E5%8A%9B/"},{"name":"倍增优化DP","slug":"倍增优化DP","link":"/tags/%E5%80%8D%E5%A2%9E%E4%BC%98%E5%8C%96DP/"}],"categories":[{"name":"雅思分手计划","slug":"雅思分手计划","link":"/categories/%E9%9B%85%E6%80%9D%E5%88%86%E6%89%8B%E8%AE%A1%E5%88%92/"},{"name":"盲人摸象","slug":"盲人摸象","link":"/categories/%E7%9B%B2%E4%BA%BA%E6%91%B8%E8%B1%A1/"},{"name":"北冥有鱼","slug":"北冥有鱼","link":"/categories/%E5%8C%97%E5%86%A5%E6%9C%89%E9%B1%BC/"}]}