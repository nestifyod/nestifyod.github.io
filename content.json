{"pages":[{"title":"message","text":"来自fygod的留言: 本网站所有内容均收集于互联网或自己创作 方便于网友与自己学习交流 如有侵权或替他问题，请留言 或在下方评论区留言 我将立即处理 来自fygod的留言: 本网站所有内容均收集于互联网或自己创作 方便于网友与自己学习交流 如有侵权或替他问题，请留言 或在下方评论区留言 我将立即处理","link":"/message/index.html"},{"title":"Gallery","text":"","link":"/album/index.html"}],"posts":[{"title":"2022.7.15","text":"核心词汇 devious /ˈdiːviəs/ 不诚实的，不直率的，欺诈的，迂回的(路线)，曲折的(道路)incumbent /ɪnˈkʌmbənt/ 在职者，现任者，在职的，现任的，有责任，必须履行cylinder /ˈsɪlɪndə/ 圆柱，圆筒状物，气缸compliment 恭维，称赞terminology 术语hurdle 障碍，栏，克服，跳过cease 停止unleash 发动，解除束缚inoculate 接种，嫁接，灌输maverick 获取，背离，行为不合常规的hover 盘旋，翱翔bungalow 平房，小屋helix 螺旋，螺旋状物inflation 通货膨胀screw /skruː/ 螺丝钉，旋紧bald 光秃的，单调的disdain 蔑视，鄙弃miserable 悲惨的，痛苦的wring 拧，绞，痛苦superfluous 多余的，不必要的，奢侈的remanent 剩余的，残余的prescribe 规定，开处方pasture 草地，牧场carbohydrate 碳水化合物buckle 扣住，弯曲，皮带扣mundane 世俗的，宇宙的spectrum 光谱，范围extravagance 奢侈，浪费，过度aggregate 集合，聚集，合计aggravate 使严重，使恶化，激怒rhetoric 花言巧语，华丽辞藻daunting 令人生畏的venerate 敬重，崇敬derive 获得，源自（insect-derived medicine 源自昆虫的药物）deprive 剥夺，剥削secrete 分泌pathogenic 致病的ubiquity 无处不见的peripheral 外围设备，周边的，外围的coefficient 系数，协同因素，共同作用wedge 挤进，楔子consecutive 连续的，连贯的coherent 连贯的consistent 始终如一的，一致的consist 包含amendment 修改，修正案permeate 弥散，渗透penetrate 渗透imperious /ɪmˈpɪəriəs/ 强迫性的imperative /ɪmˈperətɪv/ 重要紧急的，迫切的erratic 不规则的，不稳定的，漂流物rickety 摇晃的（unstable，instable）executive 执行的iterative 迭代的，重复的syndrome 综合症状systematic 系统性的comprehensive 全面的synthetic 合成的，综合的aesthetic 美学的cosmetic 化妆的adorable 可爱的，讨喜的adornment 装饰物instant 瞬间constant 常数，连续的continuous 连续的weary 劳累的exhausted 疲倦的fatigued 劳累的weird 离奇的exterminate 灭绝，毁灭extinction 灭绝profound 深远的compound 混合物（mixture，composite，synthetic stuff 合成材料）blend 搅拌（blender 搅拌机）combination 混合composite /ˈkɒmpəzɪt/ 混合成的，合成物crayon 蜡笔insanity 精神错乱的frantic 着急忙慌的embryo 胚胎，萌芽，初期的consignment 装运的货物，快递，委托，运送terrain 地形，领域dreary 令人沮丧的，沉闷的monotonous /məˈnɒtənəs/ 单调的，单调乏味的homage 敬意hegemony 霸权prefrontal 额前骨，前额的peninsula 半岛synonym 同义词（paraphrase 解释，意译）syllabus 教学大纲（teaching outline）syllable 音节，把……分成音节ambiguity 含糊，模棱两可的话genre /ˈʒɒ̃rə/ 体裁newsreel 新闻短片 同义替换小屋 bungalow，cottage，cabin，lodge，cot，chamber，the burrow螺旋 spiral，helix，screw干扰 interfere，disturb，obstruct，interrupt，bother，intervene延迟 postpone，delay，defer，put off优点 merit，advantage，virtue连续的 constant，consecutive，continuous，consistent强制性的 mandatory， compulsory，imperious，imperative激增 proliferate，surge，soar，increase sharply骤降 slump，plummet疲惫的 tired，exhausted，weary，worn out，fatigued古怪的 weird，eccentric，odd，strange，bizarre破坏 destruct，devastate，exterminate，ruin，destroy遭遇 confront，encounter，face with，come across，run into，bump into对付 cope with，deal with，tackle不稳定的 unstable，rickety，instable，erratic， fluctuate领域 domain，realm，field沉闷的，单调的 monotonous，dreary，dull，boring，plain（平淡无奇的）解释 explain，expound，explicate，interpret 看看就好binocular 望远镜drought 干旱的biology 生物学bargain 讨价还价transaction 交易trade 交易，贸易corporation 公司mathematics 数学algorithm 算法dawn 黎明previous 以前的precious 珍贵的boil 煮沸soil 土壤spoil 破坏，溺爱bend 弯曲（sharply bend 急转弯）author 作者authorize 授权authentic 真正的，可信的authorization 批准，授权书poem 诗人poetry 诗歌verse 韵文，诗，诗节poverty 贫穷theory 理论therapy 疗法irritated 恼怒地irrigation 灌溉seethe 强压怒火，翻腾sooth 真正的，抚慰的，光滑的throat 咽喉，嗓子（sore throat 嗓子疼）pump 水泵sow 播种seed 种子degrade 降级，退化burst 爆发，突发furniture 家具otherwise 否则recognize 识别，分析cheque 支票bulletin /ˈbʊlətɪn/ 公报，公布（announcement）cope 处理，应付（cope with）reluctant 不情愿的redundant 冗余的political 政治的citizen 公民，市民confident 自信的demolish 拆除designated 指定的electricity 电力，电流contain 包含，容纳retain 保持，保留protein 蛋白质valuable 有价值的vulnerable 有漏洞的experiment 实验attempt 尝试，企图，努力situation 情况（case，condition，circumstances）context 上下文，环境，语境occasion 场合bulb 电灯泡geography 地理，地形（geographic 地理学的）cautious 谨慎的，小心的particular 特比的，详尽的calorie 卡路里accent 口音ancient 古代的convenient 方便的nowhere 无处leisure 闲暇，娱乐assumption 猜想consumption 消耗ripe 熟的，成熟的raw 生的mature 成熟的suppose 假设，认为，猜想barely 仅仅，几乎不merely 仅仅handbook 手册，指南relic 遗产，遗留物legacy 遗产plain 平原，平淡无奇plaint 起诉，诉状complain 抱怨explain 解释endeavor 努力recap 简要回顾，概括in a close election 在一场势均力敌的选举中defeat the incumbent 击败现任者occupational-disease-inductive accident 职业病引发的事故wax 蜡，蜡制的，给……上蜡seal 密封(容器)，封上(信封)，海豹wax seal 蜡封glow 发光，炽热rather 稍微，有点，相当，宁愿conjunction 连词，连接，联合congestion 拥挤，堵车，人口过剩，稠密burrow 洞穴，地道，探寻，寻找spiral /ˈspaɪrəl/ 螺旋形的，螺旋式地上升（或下降），急剧增长sake 目的，缘由self-proclaimed 自称的perfectionists 完美主义者ironically 讽刺地oriented 朝向，面对，确定方向orientation 方向，目标，定向the Orient 东方drain 排水，流光，放干excrete 排泄county 郡，县dive 潜水，跳水digest 文摘，摘要，消化，吸收obstruct 阻碍，阻塞defer 遵从，听从，顺从，延期drill 训练，钻孔机，钻孔virtue 美德，优点，长处，用处 阅读刷题计划剑15阅读题题型分布 LOH 5% 选择题 14%（单选 + 多选） 匹配题 18% 判断题 19% 填空题 44% 单选题 顺序原则 一题一段 选项较长 易定位，难解题 怎么选？ 有无事实依据（细节题，一句话阐述，类似于句子匹配题） 作者意图（概括题，例子之前，类似于LOH题） 全文主旨（取标题，假大空，类似于TFNG题） 三种方法 常识判断 逻辑判断，e.g.如图1 矛盾二选一，顾名思义，不止英语题中遇到过，e.g.如图2 LOH 在文章之前出现的题 有1~2个例子 考察段落主旨 选项&gt;段落 首先在list of headings中划去做为例子的headings，以免在根据段落内容在list of headings中找出与其相匹配的段落标题时，它(它们)会干扰考试者对其他headings的选择。 在文章中把做为例子的段落划掉，以免对例子段落进行不必要的精读。 对题目中给出的段落，按照首句(第一、二句)、末句和中间句寻找主题句的方法，在list of headings中找出与其相匹配的段落标题。 剑14 Test 2 Passage 3，今晚这篇LOH做的很是不爽。 段落匹配题 剑14 Test 3 Passage 2，都对了，不过速度成问题，并且别盲目自信，这只是passage 2。","link":"/2022/07/15/2022-7-15/"},{"title":"2022.7.16","text":"核心词汇 detour 绕道，迂回junction 连接，交叉点，结合点municipal 市政的，市的mastery 掌握，精通reclaim 改造，开拓，再利用reinforce 加强，巩固，强化warrant 保证，担保，批准，证明primitive 原始的，古老的，原始人propel 推进，激励concise 简洁的，简明的brief 简明的precise 精确的unveil 揭开，揭幕，除去面纱（reveal）proclaim 宣布，宣告，声明（self-proclaimed 自称的）division 除法，部门，分配permutation 置换，组合（方式）reproduction 繁殖rectify 纠正，矫正scatter 分散，散落strew /struː/ 布满，散播在……上 同义替换资质 qualification，credential设施 equipment，facilities，installation，device推进，促进 propel，shove，thrust，promote，boost，accelerate，facilitate，gear up财产 property，asset，estate（real estate 房地产）远足 hike，excursion，trek，tramp（流浪汉）修正 remedy，amend，revise，correct，rectify包含 encase，include，encircle，incase，contain，embody缺陷 flaw，disadvantage，shortage，defect，shortcoming，weakness，drawback，handicap揭示 reveal，unveil，proclaim陈述，声明 statement，proclaim，declaim，announce，affirm，assert，allege，inhale（陈述）复制 copy，replicate，duplicate，reproduce阻碍 obstacle，hinder，block，impediment，handicap，preclude，congestion，cramp复杂的 complex，intricate，sophisticated交换 exchange，interchange，swap，permutation经验丰富的 veteran，practical，experienced，seasoned闲逛 stroll，ramble，rove，roam脆弱的，精致的 fragile，delicate，flimsy（劣质的），vulnerable（有漏洞的）兴旺发达 thrive，prosperous，flourish，boom实干的 pragmatic，do solid work，get right on the job（solving problems in a practical and sensible way rather than by having fixed ideas or theories）本土的 native，indigenous，local，aboriginal幼稚的 naive，childish 看看就好capsule 胶囊，太空舱，压缩的royal 皇家的，女王的，高贵的tar 焦油herb 香草，草药galaxy 银河，星系axis 轴，轴线submarine 海底的，潜水艇foam 泡沫，起泡spiral 螺旋形的，盘旋的helix 螺旋pendulum 钟摆equator 赤道chorus 合唱队，齐声chant 圣歌，唱，颂扬hull 船体，外壳monument 纪念碑pronunciation 发音，读法maritime 海事的，海运的manuscript 手稿，原稿premature 不成熟的，比预期早的astronauts 宇航员astronomy 天文学paradox 悖论，自相矛盾的观点auction 拍卖aesthetic 审美的，美学的distort 扭曲disorder 混乱，紊乱anatomy 解剖学accessory 附件placebo 安慰剂compatible 兼容的comparative 比较的，相当的considerable 相当大的considerate 考虑周到的commodity 日用品interchange 交换，互换statistic 统计的，统计学的embassy 大使馆ambassador 大使replicate 复制的，复制，折叠handicap 残疾，阻碍，生理缺陷coordinate 坐标，调整，协调，同等的elevate 提升，举起liter 升litter 垃圾debris /ˈdebriː/ 残骸，垃圾stroll 漫步，闲逛oriental 东方的，东方人delicate 精致的，脆弱的sophisticated 复杂的，精致的intricate 错综复杂的counterpart 副本，对应的人或物valid 有效的，有根据的，正当的vulnerable 有漏洞的hazel 榛树variant 变体apparatus 仪器property 财产intelligence 智力intelligent 聪明的; 智能的intellectual property 知识产权thrive 繁荣，兴旺prosperity 繁荣昌盛imperative 紧迫的installment 分期付款down payment 首付pragmatic 实干的（get right on the job，do solid work）sensible 明智的，理智的，朴素而实用的meditation 冥想conservatory 音乐学院，(靠房屋一侧用玻璃建造的)温室compatible 兼容的pass 在旁边走过across the bridge 穿过桥coexist 和平共处chronic 长期的chronological 按照时间顺序的overrun 超时proverb 谚语，格言telegraph 电报thermometer 温度计comets 彗星indigenous 本土的premier 首相，首位的premiere 首映，首次公演hazy 朦胧的，困惑的precipitate 加速，使……突然降临，仓促的，草率的hasty 仓促的raw 未经加工的premature 不成熟的，过早的snap 断裂，绷断，啪嗒声，匆忙的，仓促的wire 金属丝，电线，给……拍电报credential 资质，凭证premium 优质的，保险费，奖金，津贴dominant 主导地位intervene 干涉，干预slender 细长的，苗条的，微薄的excursion 远足，旅行spectacle 景观，场面，壮观artistry 艺术性，工艺，艺术效果incorporate 合并，混合stationary 固定的，静止的stationery 文具benchmark 基准，标准spin 旋转，编造utilize 利用，使用notify 通告，通知，公布anticipate 预期，期望，提前使用constitution 宪法，体制，建立，组成versatile 多才多艺的，通用的，万能的类比，推理，类似acquisition 获得，收购parasite 寄生虫calculate 计算，核对，预测calculus 微积分学deteriorate 恶化legitimate 合法的，合理的，正当的esteem 尊重，认为，考虑discipline 惩罚，纪律viable 可行的amend 修整，调整remedy 补救，纠正，治疗depression 沮丧，萧条compression 压缩，浓缩，压迫denote 表示，指示incase 包住，围绕，包装embrace 拥抱，欣然接受，乐意采纳，包括，包含reliance 信心，依赖tuition 学费，讲授tutorial 辅导的，教程surrender 投降，放弃formulate 规划，用公式表示formula 公式standby 备用品diligent 勤奋的，用功的vicious 恶毒的category 种类，分类catalogue 目录inhale 吸入，陈述veteran 老兵，经验丰富的，老练的seasoned 老练的，调好味的，加佐料 口语准备计划PART 1Taking photosDo you like to take photographs? yeah，i am a fan of taking photographs, actually i am an amateur photographer, i enjoy the sense of holding my camera or smart phone on my hand and record the fantastic scenery of animals or landscapes at that moment. Do you ever take photos of yourself? I should say i have taken some photos of myself before, but actually i don’t like this form of photographs though it can record where i am and what i am doing, i prefer to take some landscapes than the people include myself. What is your favorite family photo? Well, let me see, my favorite family photo is the one taken thirteen years ago with my whole family, my parents, my grandparents, my cousin and his parents, and the mother of my grandma who was 95 years old at that time, and that is so memoriable for me because it’s the last family photo of her with her beloved family. Do you want to improve your picture-taking skills? When i am free, i often do some research on how to improve my skills of taking photos, like the choice of shooting angles, camera lens and some other camera settings.And no mater what time it is, if i see something which drive me attention and i am equipped, i will record them as a practise. PART 2名人/普通人Describe an interesting neighbour. You should say: Who the person is How you know this person What he or she does And explain why you think this person is intelligent. The neighbour I find the most interesting is my grandpa. You heard that right he lived the next door to me before and in my opinion, he was a great writer and he wrote the story of himself, he gathered all the experience along the journey to Tibet and some other south-west places of China, formed them into a book, and this work costed him for almost 20 years, he used the computer to write, however this new technic product may be a little bit difficult for an elderly, so when i had my vacation at home, he often asked for help about the layout of the article writing tools like office and the fundmental methods of internet using. He was so persistent on his work including his book after he retired, he was a dedicated person with strong willing, as i helped him with the writing, i fount it interesting to keep on read it, though some other people don’t think so because my grandpa was only a amateur writer exactly, but all of the words he wrote was so true. There is no flowery words, but it really reflects what he saw and heard during the journey and what he learned all his life, geology. I think this is the most precious relic my old neighbour, my dear grandpa leave for me. 来自2022年第二季度口语机经库（05-08月最终版题库和答案） &amp; 2022年雅思口语题库5月-8月完整版（含答案）汇总","link":"/2022/07/16/2022-7-16/"},{"title":"2022.7.17","text":"核心词汇 theory 理论therapy 疗法creativity 创造力，创造性isolation 孤立collaboration 合作，协作calories 卡路里obesity 肥胖psychology 心理学philosophy 哲学physiology 生理学，生理机能physical 身体的，体育的physics 物理overweight 超重的eccentric 古怪的，反常vaccine 疫苗，疫苗的pervasive 普遍的，流行的，到处渗透的convict 犯罪，证明……有罪incentive 动机，刺激，激励的cohesive 凝聚的，结合的democratic 民主的，大众的undertake 承担，保证，从事portfolio /pɔrtˈfoʊlioʊ/ 公文包，文件夹，档案册bibliography 参考书目，文献目录ballet 芭蕾舞剧sail 航行，启航，帆latitude 纬度，界限，活动范围dilemma 困境diploma 毕业证书，学位证书diplomatic 外交的，老练的diplomacy 外交，外交手段clarity 清晰，明晰，透明credential 凭据qualification 资质证明parental 父母的clutch 离合器，控制，抓住，握紧peculiar 特殊的，独特的，奇怪的dilute 稀释despise 轻视，鄙视bronze 青铜，古铜色，青铜制的diminish 减少，缩少shrink 缩水shrimp 虾子dynasty 王朝，朝代destiny 命运fate 命运accent /ˈæksent/ 口音ancient 古代的prehistory 史前的ancestor /ˈænsestə/ 祖先intermediate 中间的，媒介的scene 现场，景色scenery 风景，景色，舞台布景scenario 方案，情节，剧本clue 线索plot 情节circumstances 情况下，环境，形势下episode 情节，小插曲scheme 方案scheming 策划，诡计多端vein 血管，叶脉artery 干线，动脉navigate 航行drastically 彻底的，激烈thoroughly 彻底的outright 彻底的thermometer 温度计dramatically 急剧的，戏剧性的surge 激增，汹涌，涌动soar 激增，翱翔quotation 引用，引证refuge 避难所，庇护render 提供，使成为，粉刷，渲染implement 实施，工具，手段aerial 航空的，天线（aerial photography 航拍）presumably 大概，可推测molecular 分子的anthropology 人类学orthodox 普遍接受的，正统的，规范的locomotive 火车头，运动的，移动的commerce 商业，贸易liable 有责任的，有义务的responsible 为……负责imitate 模仿intimate 亲密的interplay 相互影响overlap 重叠，同时发生collapse 崩溃，倒塌，折叠unfold 展开title 标题headline 大字标题，主角subtitle 副标题，说明，独白monologue 独白prestigious 有名望的eminent 卓越的，赫赫有名的conceal 隐藏disguise 掩盖，隐瞒disgusting 令人作呕的distinguish 区分，辨别distinction 差别distinct 不同的，明显的，有区别的district 地区distribute 分发，分配attribute 属性ozone 臭氧（ozone hole 臭氧层空洞）stretch 伸展，拉伸，有弹力的，拉紧sketch 素描 同义替换置换，易位 permutation，displace撤退 retreat，withdraw，evacuate保护，保存 conservation，preservation，retain，maintain，maintenance坚持 persevere，persistent，insist补偿 compensate，offset，render普遍流行的 pervasive，popular透明的 transparent，clarity抓住，抓紧 seize，grasp，clutch计划 program，plan，scheme鄙视 despise，underestimate，look down on航行 navigate，cruise，sail遗产 legacy，relic，heritage有名的 prestigious，famous，well-known，renowned，eminent，celebrated，distinguished威望 fame，reputation，prestige地区 region，area，zone，belt，stretch 看看就好calculus 微积分medieval 中世纪的regime 政权，政体booth 货摊，公用电话亭mainstream 主流havoc 大破坏，浩劫refund 退款，偿还，归还calculate 计算，预测，认为，打算neutron 中子vulnerable 易被……的，有弱点的prominent 突出的tropic 热带，回归线，热带的magnitude 大小，量级contract 合同，合约，收缩，感染demography 人口统计学surpass 超过，胜过，优于suitcase 手提箱，衣物箱glide 滑翔，滑行sediment 沉积，沉淀物wax 蜡，给……上蜡sculpture 雕塑，雕刻timber 木材，木料abundance 充裕，丰富marble 大理石occupation 职业，占有proclaim 宣布，宣告porcelain 瓷器corpus 语料库，文集compensate 补偿，赔偿dwell 居住，存在于expedition 远征，探险队manoeuvre 调动，操纵resolve 解决，决心，分解suspicious 可疑的，怀疑的，多疑的resemble 类似，像tilt 倾斜menace 威胁，恐吓intact 完好无损的premise 前题fabulous 极好的，传说的，难以置信的disclose 公开，揭露predominant 主要的，支配的impetus 动力，促进meditation 冥想，沉思orthodox 正统的，传统的warehouse 仓库，货栈disrupt 破坏，分裂，中断，分裂的，中断的peril /ˈperəl/ 危险，冒险，危及durable 耐用的，持久的multitude 群众，多数doctorate 博士学位transient 短暂的，瞬间的，路过的albeit 虽然，即使apparatus 装置，设备，仪器entrepreneur 企业家，主办者delegate 代表，委派……为代表delicate 微妙的，精美的，易碎的dedicate 奉献biodiversity 生物多样性lateral 侧面的，横向的impartial 公平公正的hedge 树篱，障碍circlelate 传播，循环，流通impel 推动，驱使，激励（propel）discriminate 歧视，区别，辨别conform 一致的，顺从的，使遵守denounce 谴责，告发，公然抨击census 人口普查，人口调查consensus 一致的意见，共识receptive 接纳的，容纳的plight 困境，誓约，保证，约定entail 使需要，必须，引起，继承optimum 最佳效果，最适宜的negotiate 谈判，商议apes 猿类manuscript 手稿coincide 一致，符合，同时发生proceed 开始，行进，继续进行distill 蒸馏，提炼strain 张力，拉紧displace 取代，置换，转移retreat 撤退differentiation 分化，区别allege 宣称，断言democracy 民主，民主政治warfare 战争，冲突memorize 记忆，存储brink 边缘conservation 保存，保持lapse 小错，流逝evaporate 蒸发，(使)挥发evacuate 撤退prolong 延长，延申acclaim 称赞，欢呼shuttle 穿梭班机，公共汽车proponent 支持者，建议者outright 完全的，彻底的cosmetic 美容的，化妆品taxonomy 分类学，分类法adornment 装饰，装饰品notorious 著名的，声名狼藉的contradict 反驳，否定，与……矛盾barrel 桶，枪管aggravate 加重，使恶化parade 游行，阅兵","link":"/2022/07/17/2022-7-17/"},{"title":"2022.7.18","text":"核心词汇 serene /səˈrin/ 宁静humble 谦逊的transient 短暂的instant 瞬间的constant 常量，连续的suspicious 可疑的，多疑的headquater 设立总部seminar 研讨会publicize 宣传，公布stray 流浪，迷路的，偶遇的rim 边，边缘transcend 胜过，超越outweigh 胜过，大于，超过，重于overweight 超重fringe 边缘，形成……的边缘，边缘的fence 栅栏hedge 树篱，防止损失的手段，避免正面回答，拐弯抹角multitude 群众，众多，大量，民众defer 推迟，延期gossip 小道传闻，闲聊arouse 唤醒，引起evoke 唤起，引起engender 产生，引起elicit 引起，诱出provoke 激起，引发undertake 承担，保证，从事withhold 拒绝给，保留，隐瞒，抑制withstand 抵挡，反抗infectious 有感染力的pledge 保证，抵押plague 瘟疫，灾祸，折磨，使苦恼torture 折磨symptom 症状，征兆sketch 素描，梗概ethical 伦理的，道德的bypass 绕过，旁路，支路stubborn 顽强的monopoly 垄断manipulate 操纵appendix 附录，附加物accessories 配件，附属物mimic 模仿，模拟的commence 开始，着手，获得学位simulate 模仿，假装disguise 假装pretend 佯装，装作intricate 错综复杂的inclination 倾向，斜坡slope 坡地，倾斜tilt 倾斜lean 前俯，倚靠leak 泄露，渗入pursuit 追求persuade 说服purchase 购买designated 指定的allocate 分配，指定apportion 分配，分派proportion 部分，份额，比例scrape 刮overwhelm 淹没，压倒telepathy 心灵感应conceive 构思，构想，怀孕perceive 感知，认为，注意到mainspring 主要动力，主要原因spectator 观众，旁观者bystander 旁观者audience 观众passerby 路人comprehend 理解，领悟appreciate 欣赏，感谢，领悟到conspicuous /kənˈspɪkjuəs/ 明显的，显而易见的evidence 证据，根据witness 目击者，见证testimony 证词，证据，口供proof 证明edible 可食用的susceptible 易受影响的recap 概括，简要回顾speculate 推测，思索appal 惊吓，减弱pastime 娱乐，消遣resort 求助，诉诸，旅游胜地dispense 分配，分发dispatch 派遣，分发as for 至于，就……方面来说weave 织 同义替换边缘 rim，brink，edge，margin，border，fringe胜过 surpass，transcend，outweigh，excel，exceed群众 multitude，masses，general publicdefer，postpone，delay，put off激活，唤起 activate，sensitized，stimulate，impetus，provoke，engender，elicit，evoke，arouse有吸引力的 attractive，appealing，charming显而易见的 conspicuous，obvious，apparent，noticeable闲暇，娱乐 entertainment，amusement，recreation，pastime，leisure缓解，放轻松 ease，alleviate，release，relief，allay，lessen，sooth，comfort差距 gap，difference value 看看就好adorable 可爱的rigid 僵硬的，死板的suffocating 令人窒息的solicit 征求，招徕（嫖客）offspring 孩子，后代burgeon 萌芽，发芽embryo 胚胎grief 悲伤benchmark 基准landmark 里程碑climax 高潮，顶点pottery 陶器nicotine 尼古丁grain 谷物cereal 谷类moonlight 月光comets 彗星satellite 卫星strand 搁浅（death stranding 死亡搁浅）vintage 优质的，收获，制造年代bounds 界限，跳动，弹回leaps 跳跃，剧增，急变drones 遥控飞机，雄峰gadget 小玩意，小装置stumbling 摇摇晃晃的，跌跌撞撞的alleviate 减轻，缓和muscular 肌肉发达的，健硕的coronae 光圈，圆烛架wit 智力，才智genre 类型，题材，风俗画的petrified 惊呆的，石化的exert 运用，挥发，表现出sentient 有感觉的，意识到的consciousness 清醒状态unconsciousness 昏迷insanity 精神失常out of reach 遥不可及的mysterious 难以理解的，神秘的lunar 月亮的，月球的full moon 满月sleeping patterns 睡眠模式deep sleep 深度睡眠moonstruck 疯狂的gravitational pull 引力celestial 天的，天空的lunar cycle 月亮周期ancient myths 古代神话mirth 欢笑，欢乐exert influence 施加影响saturated 渗透的，浓的sodium 钠fertility 富饶，生育率inmates 同住者，同狱犯人widen 放宽broaden 扩宽 口语准备计划PART 1Study or workDo you work or are you a student? I’m a student at Henan Polytechnic University in JiaoZuo. I just finished my junior year and i am ready for my senior year. What subject are you studying? I’m studying for a Bachelor’s degree and specializing in the field of Computer Science. Why did you choose that subject? I chose CS because i found it interesting that machines can also have the ability to think and even make decisions, I’m always full of the spirit of exploration about what I am curious about. What would you like to do in the future? I want to be an algorithm engineer, because i have an excellent foundation of mathematics and i am accustomed to establishing model for a specific problem and try to connect with its corresponding application in daily life. What are the most popular subjects in China? It’s hard to say nowadays. You know, due to the globalization, our country is much more developed than ever. Students can choose the subjects they are really interested in, no longer as before, mandatory course only, so all of subjects are popular among specific parts of people. Do you think it’s important to choose a subject you like? I think it’s an essential point for us to make full consideration of the choice before we start to study. Because only if you evaluate your interest in this subject and the prospective of it, you would find it worth for you to carry on the process of learning and the profound research in your career later on. Are you looking forward to working? Well, i will consider an internship, because for me, the work experience can help me to transform the skills learned from the textbooks into action, so it can not only consolidate my knowledge but also practice my communication skills with others and furthermore, these will help me with the further study. Do you prefer to study in the mornings or in the afternoons? I prefer to study in the mornings because i am a self-discipline person. I wake up early in the morning and recite some English vocabulary. Then i will walk with my dog and hear some audio like BBC Learning English, this will arouse my whole day spirit. Is your subject interesting to you?/Do you like your subject? Why? Absolutely it attracted me a lot. I spent 2 days on the application form in order to learning CS in the university. And during my college time, i always show more curiosity on the new knowledge than others and get the high grades in major courses. Is there any kind of technology you can use in study? Of course, for me, the electronic devices like tablet and laptop are used by me the most frequently. Both of them are very helpful and can improve my efficiency in study. Laptop just like a synthetic tool box and the tablet is the abbreviated version of it. Comparatively, a laptop assembles most of the coding environment but tablet doesn’t, on the other hand, a tablet own more convenience than a laptop.","link":"/2022/07/18/2022-7-18/"},{"title":"2022.7.19","text":"核心词汇 hint 暗示detach 拆卸，(使)分开，脱离，挣脱attach 贴上，固定，附上，与……有联系adhere 遵守，附着，黏附sensation 感觉，轰动，感动sentient 有感觉能力的elastic 有弹性的，灵活的resilience 恢复，弹力，适应力reclaim 取回，拿回，开垦，改造integrity 完整，正直，诚实herbicide 除草剂degenerate 退化degradation 恶化deforestation 退森林化desertification 沙漠化terrify 恐吓，使恐怖circumstance 场合，条件，环境circumscribe 限制，在……周围画线creativity 创造性dedicate 致力，献身stride 大步，进展，跨过perception 知觉，感觉，看法sanitary 为生的，清洁的enlighten 启发，启蒙epidemic 流行的，传染性的，传染病numerical 数值的，数字的module 模块，组件subsidy 补贴，津贴moist 潮湿的，多雨的moisture 潮湿furnish 提供，供应，装备furniture 家具facility 设施，天资，特定用途的（场所）bizarre 奇异的splash 溅，泼splendid 壮观的overdraw 透支，夸张extravagant 奢侈的Exaggeration 夸张overstate 言过其实spatial /ˈspeɪʃl/ 空间的groove 沟槽，辙，纹trivial /ˈtrɪviəl/ 不重要的，琐碎的，微不足道的entitle 称为，命名，给予权利entail 继承，涉及，需要，使必要detrimental 不利的，有害的groan 呻吟twist 编制，拧，扭sufficient 足够的，充分的efficient 高效的narrative 叙述，故事，叙事的demolish 拆除，破坏compile 编译，汇编deficit 赤字，不足，缺少transaction 交易，事务，办理allergy 过敏症，厌恶disperse 分散，传播，分散的accredit 授权，信任reciprocal /rɪˈsɪprəkl/ 倒数，互相起作用，相互的，倒数的profound 深厚的，意义深远的warrant 保证，授权令guarantee 保证without the effort 不用费力downhill 下山，下坡craft 手艺be accustomed to doing sth. 习惯于……detain 扣留fracture (指事实)骨折，(指状态)断裂fascinating 极有吸引力的conscious 有意识的intriguing 有趣的，神秘的，引人入胜的 同义替换夸大其实 overstate，overdraw，exaggeration分散 disperse，spread，scatter，decentralize，splash授权 accredit，authorize，warrant限制 restrict，circumscribe，limit暗示 imply，intimate，hint斜坡，下坡 downhill，inclination，slope，tilt 看看就好vessel 容器，轮船satellite 卫星acoustic wave 声波magnetic wave 电磁波fluid /ˈfluːɪd/ 液体，流体，流畅优美的，易变的liquor 酒，浸泡，喝酒vehicles 载具liquid 液体illustrations 阐释niece 侄女medieval 中世纪的ballroom 舞池long gowns 长袍custom 风俗costume 戏服，服装customers 顾客observatory 天文台aurora 极光excursion 远足beverage 饮料refreshment 点心refurbishment 翻修adornment 装修terrace 露台，梯田bluff 虚张声势violet 紫罗兰envelopes 信封brochures 小册子leaflets 传单flier 飞页panoramic 全景的，远景的cortex 皮质，树皮，果皮ultraviolet 紫外线的，紫外光silt 淤泥protein 蛋白质，蛋白质的alloy 使成合金，合金belt 地带，…带tenant 承租人，租借，房客narcissist /ˈnɑːrsəˌsist/ 自恋者intersection 交叉，十字路口mammal 哺乳动物alliance 联盟，联合","link":"/2022/07/19/2022-7-19/"},{"title":"2022.7.20","text":"核心词汇 live up to 不辜负，符合（fail live up to 辜负……）account for 对……负责，解释了……thereby 因此，由于，从而impulsive 冲动的concession 让步，妥协，承认compromise 让步painstaking 艰苦的，勤勉的optimal 最佳的，最理想的optimum 最佳的，最适宜的enlist 支援，从军，赞助entitle 称为，命名，给予权利entail 继承，涉及，需要archive 档案馆，把……存档stream 溪流，流动，流出ascertain 确定，查明automatically 自动地，机械地imperative 必要的事，命令，必要的，紧急的insulate 隔离，使隔绝subscribe 签署，订阅，捐赠prescribe 开处方，规定circumscribe 限制，约束prehistoric 史前的，陈旧的compulsory 义务的，强制的，规定动作mandatory 强制的，义务的，受托者sensor 传感器authentic 真正的，可信的verdict 结论，裁定genre 题材invert 转化，反转execution 执行implement 实施unpredictable 不可预知的，出乎意料的gauge /ɡeɪdʒ/ 测量，估计evaluate 估计estimate 估计，估价underestimate 低估template 模板，样版reserve 储备，保留，预定differentiate 区别distinction 差别extinction 灭绝scrap 废弃，拆毁demolish 拆除destruction 摧毁impair 损害，削弱despair 绝望repair 修理apparatus 设备reclaim 取回，开垦，利用，矫正deceive 欺骗（deceptive 骗人的）conceive 构想，怀孕perceive 感知，意识到perception 直觉，感知，看法，见解depict 描述dispute 争端，纠纷tangle 纠纷，纠缠nominate 推荐，提名，任命dominate 主导eventually 最终的practically 几乎，差不多，实事求是，实际地actually 事实上abruptly 突然地susceptible 敏感的suspicious 可疑的baggage 行李，包袱，恩怨particular 特别的，特定的peculiar 奇特的fabulous 美丽的adornment 可爱的annotate 注释thornydemanding 同义替换估计 evaluate，estimate，gauge欺骗 deceive，fraud，cheat描述 depict，illustrate减缓 allay，alleviate，relief，lessen，ease，release（释放），relax削弱 impair，weaken，cripple 看看就好pedometer 计步器chronological 按时间顺序procedure 手续，程序，步骤dissertation 论文theoretical 空谈的，理论上的flatter 讨好，谄媚sanctuary 庇护所smash 猛击terrific 极好的gravity 重心，地心引力tropical 热带的fury 暴怒pessimistic 悲观的pathetic 可悲的rectangle 长方形triangle 三角形artefact 工艺品，人工制品artisan 工匠pesticide 杀虫剂herbicide 除草剂verbal 口头的cassette 盒式磁带hydrogen 氢supplement 增补，补充，补充物supplies 物资curiosity 好奇心tablet 药片，写字板，平板电脑merchandise 商品，货物，经商artery 动脉，干道，主流stitch 针脚，缝合protocol 协议，草案catalogue 目录innate 先天的，固有的comet 彗星lane 小巷，航线alley 小巷，胡同（bowling alley 保龄球场）ally 联盟allay 减轻，减缓alloy /ˈælɔɪ / 合金，把……铸成合金","link":"/2022/07/20/2022-7-20/"},{"title":"2022.7.21","text":"核心词汇 fume 烟，愤怒，恼怒interpersonal 人际的，人与人之间的personnel 人事部prompt 迅速的，立刻的，促进prominent 显著的hierarchy 层级，等级制度torture 折磨afflict 折磨，使苦恼setback 挫折，退步drawback 缺点ignite 点燃，使燃烧mechanical 机械的，力学的detach 分离，派遣dispatch 派遣detain 扣留revise 修订，校订，复习desolate 荒凉的，使荒凉，使孤寂precede 领先，在……前面perplex 使困惑，使为难，使复杂化scatter 分散，传播，反射noteworthy 值得注意的，显著的prosper 繁荣，昌盛thrive 繁盛alley 小巷，小径metropolitan 大都市的distinct 明显的，不同的，独特的eminent 杰出的，明显的leap 飞跃，跳跃appraisal 评价，估价，估计（appraise v.）intuition 直觉tuition 学费insight 直觉，洞察力，领悟discernment 辨别力instinct 本能，天性，直觉，充满的propound 提出，提议，考虑contemporary 当下的，同代人temporary 暂时的temper 脾气，心情extemporary 无准备的extemporaneous 即兴的virtual 虚拟的，实质上的synthetic 综合的，合成的，人造的pursue 追赶，继续，从事persuade 说服purchase 购买depletion 消耗，损耗substitute 替代品substance 物质antibody 抗体signify 表示，意味，预示tournament 锦标赛reign 统治，支配region 地区foster 促进，培育sanction 制裁，处罚fracture 破裂，断裂obscure 昏暗的，晦涩的，不清楚的correspond 符合，一致，通信enforce 实施，执行，强迫attain 得到gain 获得，赢得，增加，好处obtain 获得，存在，流行acquisition 获得acquirement 收购，获得，学得intriguing 有趣的intrigues 激起……的兴趣，引发……的好奇心，密谋策划（intrigue的第三人称单数）spontaneous 自发的simultaneously 同时地concurrently 并发地 同义替换获得 obtain，attain，get，gain，acquire估计 measurement，appraisal，evaluation，assessment，estimate折磨 torture，afflict，plague，inflict提出 propound，raise，propose，suggest杰出的 eminent，prominent，extraordinary，brilliant，excellent，transcendental，noteworthy转瞬即逝的 transient，instant，immediate，extemporary直觉 insight，intuition领域，地区 district，region，field，realm，domain，area，prefecture 看看就好choir 唱诗班chorus 合唱队symphony 交响乐，和声advent 到来，出现，降临节telepathy 心灵感应sympathy 同情empathy 移情，共鸣，同情stem 梗茎，阻止，遏制（science，technology，engineering，mathematics）perfume 香水，香气，发散香气mansion 大厦（complex）architect 建筑师shipwreck 沉船 写作登月计划因果关系引起 trigger A is the stem or even the root of B. B is the natural fruit of A. 三过度 Heavy exposure to Heavy reliance on Heavy addict to 拥有 褒义：enjoy 贬义：suffer 导致 cause result in lead to bring about contribute to be the major contributor to be chiefly responsible for ripple outward through … Sentence Practice 科技使人们的生活更加方便 过度看电视导致孩子视力不好 英国医生的数量比美国多 商业广告是最有吸引力的媒体 主语变具体 e.g. 应该投资于互联网因为互联网影响经济 We should give money to the Internet for the simple reason that it affects the economy. We -&gt; business men and governments It is business men and governments’ responsiblity to give money to the Internet for the simple reason that the effects of it ripple outward through the economy. With … with the help/aid of with the advent of + 科技方面/……的社会（phone/face-oriented society） 科技使人们的生活更加方便 With the help of science and technology, people enjoy more convenient life world-wildly. 随着看脸时代的来临，找工作越来越难了 With the advent of face-oriented society, the difficulty of job hunting becomes much greater than before. be the contributor to be the major contributor to be chiefly responsible for 过度看电视导致孩子视力不好 Watching TV too much is the major contributor to children’s bad eyesight. Too much time spending on TV is chiefly responsible for children’s bad eyesight. Heavy exposure to television is the major contributor to children’s bad eyesight. 过度的电脑游戏会导致孩子的体育锻炼减少 Heavy addict to computer games is the major contributor to the reduction of the sports time. 多用名词性的表达 Heavy exposure to Heavy reliance on Heavy addict to 口语准备计划好词好句the classical architecture 古典建筑the exotic cuisine 异国佳肴under the circumstances 在这种情况下 阅读刷题计划剑桥雅思阅读同义替换词汇汇总表","link":"/2022/07/21/2022-7-21/"},{"title":"Kruskal-并查集","text":"Kruskal算法 假设G=(V,E)是连通图，将G中的边按权值从小到大的顺序排列 将n个顶点看成n个集合 按权值从大到小的顺序选择边，所选边应满足两个顶点不在同一个顶点集合内，即加入此边后不会在生成树中产生回路，将该边放到生成树边的集合中。同时将该边的两个顶点所在的顶点集合合并。 重复2，直到所有的顶点都在同一个顶点集合内。 并查集 Make_Set(x) 把每一个元素初始化为一个集合初始化后每一个元素的父亲节点是它本身，每一个元素的祖先节点也是它本身（也可以根据情况而变）。 Find_Set(x) 查找一个元素所在的集合查找一个元素所在的集合，其精髓是找到这个元素所在集合的祖先！这个才是并查集判断和合并的最终依据。判断两个元素是否属于同一集合，只要看他们所在集合的祖先是否相同即可。合并两个集合，也是使一个集合的祖先成为另一个集合的祖先，具体见示意图 Union(x,y) 合并x,y所在的两个集合合并两个不相交集合操作很简单：利用Find_Set找到其中两个集合的祖先，将一个集合的祖先指向另一个集合的祖先。 优化 Find_Set(x)时 路径压缩寻找祖先时我们一般采用递归查找，但是当元素很多亦或是整棵树变为一条链时，每次Find_Set(x)都是O(n)的复杂度，有没有办法减小这个复杂度呢？答案是肯定的，这就是路径压缩，即当我们经过”递推”找到祖先节点后，”回溯”的时候顺便将它的子孙节点都直接指向祖先，这样以后再次Find_Set(x)时复杂度就变成O(1)了，如下图所示；可见，路径压缩方便了以后的查找。 Union(x,y)时 按高度合并即合并的时候将元素少的集合合并到元素多的集合中，这样合并之后树的高度会相对较小。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364int father[MAX]; /* father[x]表示x的父节点*/int rank[MAX]; /* rank[x]表示x的高度*//* 初始化集合*/void Make_Set(int x){ father[x] = x; //根据实际情况指定的父节点可变化 rank[x] = 0; //根据实际情况初始化高度也有所变化}/*非递归 Make_Set*/// void Make_Set(int x)// {// father[x] = -1;// rank[x] = 0;// }/* 查找x元素所在的集合,回溯时压缩路径*/int Find_Set(int x){ if (x != father[x]) { father[x] = Find_Set(father[x]); //这个回溯时的压缩路径是精华 } return father[x];}/*非递归 Find_Set*/// int Find_Set(int x)// {// while (father[x] != -1)// {// x = father[x];// }// return x;// }/* 按高度合并x,y所在的集合 下面的那个if else结构不是绝对的，具体根据情况变化 但是，宗旨是不变的即，按高度合并，实时更新高度。*/void Union(int x, int y){ x = Find_Set(x); y = Find_Set(y); if (x == y) return; if (rank[x] &gt; rank[y]) { father[y] = x; } else { if (rank[x] == rank[y]) { rank[y]++; } father[x] = y; }} 题目It is not easy to identify all the suspects when a student is recognized as a suspect. Your job is to write a program which finds all the suspects. Input The input file contains several cases. Each test case begins with two integers n and m in a line, where n is the number of students, and m is the number of groups. You may assume that 0 &lt; n &lt;= 30000 and 0 &lt;= m &lt;= 500. Every student is numbered by a unique integer between 0 and n−1, and initially student 0 is recognized as a suspect in all the cases. This line is followed by m member lists of the groups, one line per group. Each line begins with an integer k by itself representing the number of members in the group. Following the number of members, there are k integers representing the students in this group. All the integers in a line are separated by at least one space.A case with n = 0 and m = 0 indicates the end of the input, and need not be processed. Output For each case, output the number of suspects in one line. Sample Input &amp; Output 12345678910111213100 42 1 25 10 13 11 12 142 0 12 99 24200 21 55 1 2 3 4 511 010 0 递归版本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;using namespace std;int n, m, i, j;int father[30005], num[30005];void makeSet(int n){ for (i = 0; i &lt; n; i++) { father[i] = i; //使用本身做根 num[i] = 1; }}int findSet(int x){ if (father[x] != x) //合并后的树的根是不变的 { father[x] = findSet(father[x]); } return father[x];}void Union(int a, int b){ int x = findSet(a); int y = findSet(b); if (x == y) { return; } if (num[x] &lt;= num[y]) { father[x] = y; num[y] += num[x]; } else { father[y] = x; num[x] += num[y]; }}int main(){ while (scanf(&quot;%d %d&quot;, &amp;n, &amp;m) != EOF &amp;&amp; n != 0) { makeSet(n); for (i = 0; i &lt; m; i++) { int count, first, b; scanf(&quot;%d %d&quot;, &amp;count, &amp;first); for (j = 1; j &lt; count; j++) { scanf(&quot;%d&quot;, &amp;b); Union(first, b); } } printf(&quot;%d\\n&quot;, num[findSet(0)]); } return 0;} 并查集–学习详解","link":"/2022/07/18/Kruskal-%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"title":"一些有趣的题目","text":"充实的寒假生活(GREEDY/DP)描述 寒假马上就要到了，龙傲天同学获得了从第0天开始到第60天结束为期61天超长寒假，他想要尽可能丰富自己的寒假生活。现提供若干个活动的起止时间，请计算龙同学这个寒假至多可以参加多少个活动？注意所参加的活动不能有任何时间上的重叠，在第x天结束的活动和在第x天开始的活动不可同时选择。 输入 第一行为整数n，代表接下来输入的活动个数(n &lt; 10000)紧接着的n行，每一行都有两个整数，第一个整数代表活动的开始时间，第二个整数代表全结束时间 输出 输出至多参加的活动个数 样例输入 12345650 01 12 23 34 4 样例输出 15 解决 1234567891011121314151617181920212223242526class Solution(object): def eraseOverlapIntervals(self, intervals): &quot;&quot;&quot; :type intervals: List[List[int]] :rtype: int &quot;&quot;&quot; if not intervals or len(intervals) == 0: return 0 intervals.sort(key = lambda x: x[0]) # 按左端点从小到大排序 temp_pos = 0 cnt = 0 for i in range(1, len(intervals)): if intervals[temp_pos][1] &gt;= intervals[i][0]: # 当当前区间右端点&gt;i区间左端点 if intervals[i][1] &lt; intervals[temp_pos][1]: # 当i区间右端点&lt;当前区间右端点，表示i区间被覆盖在当前区间中 temp_pos = i # 更新temp_pos，选择覆盖范围小的i区间 cnt += 1 # 当前区间右端点&gt;i区间左端点都要计数+1 else: temp_pos = i # 当当前区间右端点&lt;=i区间左端点，表示不重叠，要更新temp_pos return len(intervals)-cntif __name__ == &quot;__main__&quot;: n=int(input()) intervals=[] for i in range(n): intervals.append(list(map(int, input().split()))) print(Solution().eraseOverlapIntervals(intervals)) 和为给定数描述 给出若干个整数，询问其中是否有一对数的和等于给定的数。 输入 共三行：第一行是整数n(0 &lt; n &lt;= 100,000)，表示有n个整数。第二行是n个整数。整数的范围是在0到108之间。第三行是一个整数m（0 &lt;= m &lt;= 230)，表示需要得到的和。 输出 若存在和为m的数对，输出两个整数，小的在前，大的在后，中间用单个空格隔开。若有多个数对满足条件，选择数对中较小的数更小的。若找不到符合要求的数对，输出一行No。 样例输入 12342 5 1 46 样例输出 11 5 解决 123456789101112131415161718192021222324252627def find(key,base,top): #二分查找 while base&lt;=top: mid = (base+top)//2 if a[mid]==key: return True elif a[mid]&lt;key: base=mid+1 else: top=mid-1 return False n=int(input())a=list(map(int,input().split()))a=sorted(a)flag=0# print(a)m=int(input())for i in range(n): key=m-a[i] base=i+1 top=n-1 if find(key,base,top): print(a[i],key) flag=1 breakif flag==0: print(&quot;No&quot;) 求逆序对数描述 对于一个长度为N的整数序列A，满足i &lt; j且 Ai &gt; Aj.的数对(i,j)称为整数序列A的一个逆序请求出整数序列A的所有逆序对个数 输入 输入包含多组测试数据，每组测试数据有两行第一行为整数N(1 &lt;= N &lt;= 20000)，当输入0时结束第二行为N个整数，表示长为N的整数序列 输出 每组数据对应一行，输出逆序对的个数 样例输入 123456751 2 3 4 555 4 3 2 1110 样例输出 1230100 解决1 冒泡，可能会超时 1234567891011121314151617def main(): while True: n = int(input()) if n==0: return ll = list(map(int, input().split())) # print(ll) c=[0 for i in range(101)] group=0 for i in range(n-1): for j in range(i,n-1): if ll[j]&gt;ll[j+1]: group+=1 print(group)if __name__ == '__main__': main() 解决2 归并 1234567891011121314151617181920212223242526272829303132333435363738def merge_sort(a): s = 0 if len(a) &lt;= 1: return 0 mid = len(a) // 2 l = a[:mid] r = a[mid:] s += merge_sort(l) + merge_sort(r) i = j = k = 0 while (i &lt; len(l) and j &lt; len(r)): if (l[i] &lt;= r[j]): a[k] = l[i] i += 1 k += 1 else: a[k] = r[j] j += 1 k += 1 s += len(l) - i while (i &lt; len(l)): a[k] = l[i] i += 1 k += 1 while (j &lt; len(r)): a[k] = r[j] j += 1 k += 1 return sdef main(): while True: n = int(input()) if n==0: return ll = list(map(int, input().split())) print(merge_sort(ll))if __name__ == '__main__': main() 小木棍描述 小明将一批等长的木棍随机切成最长为50单位的小段。现在他想要将木棍还原成原来的状态，但是却忘记了原来的木棍数量和长度。请写一个程序帮助他计算如果还原成原来的等长木棍，其长度可能的最小值。所有的长度均大于0。 输入 输入包含多个实例。每个实例有两行，第一行是切割后的木棍数量n（最多64个），第二行为n个以空格分开的整数，分别为每根木棍的长度。输入的最后以n为 0 结束。 输出 对于每个实例，输出一行其长度的可能的最小值。 样例输入 1234595 2 1 5 2 1 5 2 141 2 3 40 样例输出 1265 来源 来自计算概论B期末考试，本题对数据进行了弱化 解决 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647N=105a=[0 for _ in range(N)]v=[0 for _ in range(N)]target=0n=0maxn=0def dfs(cnt, len, pos): if cnt == target: return True #拼够了根数，符合题意 if len == maxn: return dfs(cnt+1, 0, 0) #拼完了一根 继续下一根 i = pos while i&lt;n: if v[i]==0 and len+a[i]&lt;=maxn: v[i]=1 if dfs(cnt, len+a[i], i): return True v[i]=0 if len == 0: return False #凑第一根的时候可以随便选，如果随便选都凑不成一根，那这个长度不行 神奇剪枝！！ while i+1&lt;n and a[i+1]==a[i]: i += 1 #如果用当前的小木段拼凑 失败则与它等长的同样失败，小剪枝 i += 1 return Falsewhile True: n=int(input()) if n==0: break arr = input() a = [0 for _ in range(N)] a = [int(n) for n in arr.split()] asum = 0 asum = sum(a) a=sorted(a,reverse=True) maxn = 0 maxn=a[0] while maxn &lt;= asum: if asum%maxn == 0: target = asum / maxn v = [0 for _ in range(N)] if dfs(0, 0, 0): break maxn += 1 print(maxn) 修仙之路描述 修仙之路长漫漫，逆水行舟，不进则退！你过五关斩六将，终于来到了仙界。仙界是一个r行c列的二维格子空间，每个单元格是一个”境界“，每个境界都有等级。你需要任意选择其中一个境界作为起点，从一个境界可以前往上下左右相邻四个境界之一 ，当且仅当新到达的境界等级增加。你苦苦行走，直到所在的境界等级比相邻四个境界的等级都要高为止，一览众山小。请问包括起始境界在内最长修仙路径需要经过的境界数是多少？ 输入 第一行为两个正整数，分别为r和c（1&lt;=r,c&lt;=100）。接下来有r行，每行有c个0到100000000之间的整数，代表各境界的等级。 输出 输出一行，为最长修仙路径需要经过的境界数（包括起始境界）。 样例输入 1234565 51 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9 样例输出 125 解决1 没有考虑位于边界的“仙境” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import java.util.Scanner;/**] * * 5 5 * 1 2 3 4 5 * 16 17 18 19 6 * 15 24 25 20 7 * 14 23 22 21 8 * 13 12 11 10 9 * * */public class Main { public static void main(String[] args) { Scanner sc =new Scanner(System.in); int m= sc.nextInt(); int n =sc.nextInt(); int [][] nums = new int[m][n]; for(int i=0;i&lt;m;i++){ for(int j = 0;j&lt;n;j++){ nums[i][j] = sc.nextInt(); } } /* int [][] dp = new int[m][n]; dp[0][0] =1; int target =0; // i+1,j // i-1,j // i,j+1// i,j-1 for(int i=0;i&lt;m;i++){ for(int j=0;j&lt;n;j++){ if(i==0&amp;&amp;j==0){ continue; } if(i+1&lt;m&amp;&amp;j&lt;n &amp;&amp; nums[i+1][j]&lt;nums[i][j]){ dp [i][j] =Math.max(dp[i+1][j],dp[i][j])+1; } if (0&lt;=i-1&amp;&amp;j&lt;n&amp;&amp; nums[i-1][j]&lt;nums[i][j]){ dp [i][j] =Math.max(dp[i-1][j],dp[i][j])+1; } if(i&lt;m&amp;&amp;j+1&lt;n &amp;&amp; nums[i][j+1]&lt;nums[i][j]){ dp [i][j] =Math.max(dp[i][j+1],dp[i][j])+1; } if(i&lt;m&amp;&amp;j-1&gt;=0 &amp;&amp; nums[i][j-1]&lt;nums[i][j]){ dp [i][j] =Math.max(dp[i][j-1],dp[i][j])+1; } int tmp = nums[i][j]; int tmp1 = dp[i][j]; target = Math.max(dp[i][j],target); } } System.out.println(target);*/ int a = dfs(nums,0,0,m,n,1); System.out.println(a); } public static int dfs(int [][] nums ,int i,int j ,int m, int n ,int tt ){ if(i&lt;0 || i&gt;m || j&lt;0||j&gt;n){ return 0; } if(is(nums,i,j,m,n)==4){ return tt; } int a =0; int b=0; int c=0; int d=0; if(i-1&gt;=0&amp;&amp;nums[i][j]&lt;nums[i-1][j]){ a= dfs(nums, i-1, j, m, n,tt+1); } if(i+1&lt;m&amp;&amp;nums[i][j]&lt;nums[i+1][j]){ b= dfs(nums, i+1, j, m, n,tt+1); } if(j-1&gt;=0&amp;&amp;nums[i][j]&lt;nums[i][j-1]){ c= dfs(nums, i, j-1, m, n,tt+1); } if(j+1&lt;n&amp;&amp;nums[i][j]&lt;nums[i][j+1]){ d= dfs(nums, i, j+1, m, n,tt+1); } a= Math.max(a,b); a= Math.max(a,c); a= Math.max(a,d); return a; } public static int is(int [][] nums,int i,int j,int m,int n){ int tar=0; if(i-1&gt;=0){ if( nums[i][j]&gt;nums[i-1][j]){ tar++; } } if(i+1&lt;m){ if( nums[i][j]&gt;nums[i+1][j]){ tar++; } } if(j-1&gt;=0){ if( nums[i][j]&gt;nums[i][j-1]){ tar++; } } if(j+1&lt;n){ if( nums[i][j]&gt;nums[i][j+1]){ tar++; } } return tar; }} 来自啊鱼咕嘟 解决2 12345678910111213141516171819202122232425262728# 5 5# 1 2 3 4 5# 16 17 18 19 6# 15 24 25 20 7# 14 23 22 21 8# 13 12 11 10 9n,m=map(int,input().split())nums = []for _ in range(n): nums.append(list(map(int, input().split())))dp=[[-1]* m for _ in range(n)]move=[[0,1],[1,0],[-1,0],[0,-1]]def dfs(i,j): if dp[i][j]!=-1: return dp[i][j] ret=1 for oi,oj in move: ni,nj=i+oi,j+oj if 0&lt;=ni&lt;n and 0&lt;=nj&lt;m and nums[i][j]&gt;nums[ni][nj]: ret=max(ret,dfs(ni,nj)+1) dp[i][j]=ret return dp[i][j]res=0for i in range(n): for j in range(m): res=max(res,dfs(i,j))print(res) 拦截导弹描述 某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。 输入导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数），计算这套系统最多能拦截多少导弹。 输入 第一行是一个整数N（不超过15），表示导弹数。第二行包含N个整数，为导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数）。 输出 一个整数，表示最多能拦截的导弹数。 样例输入 128389 207 155 300 299 170 158 65 样例输出 16 解决 123456789101112131415161718i=0data = [0 for _ in range(100)]ans = [0 for _ in range(100)]n=int(input())arr=input()data = [int(n) for n in arr.split()]ans[0] = 1maxt = 1for j in range(1, n): ans[j] = 1 for i in range(0, j): if data[i]&gt;=data[j]: if ans[i]+1&gt; ans[j]: ans[j] = ans[i]+1 if ans[j]&gt; maxt: maxt = ans[j]print(maxt) 采药（DP）描述 辰辰是个很有潜能、天资聪颖的孩子，他的梦想是称为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。” 如果你是辰辰，你能完成这个任务吗？ 输入 输入的第一行有两个整数T（1 &lt;= T &lt;= 1000）和M（1 &lt;= M &lt;= 100），T代表总共能够用来采药的时间，M代表山洞里的草药的数目。接下来的M行每行包括两个在1到100之间（包括1和100）的的整数，分别表示采摘某株草药的时间和这株草药的价值。 输出 输出只包括一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。 样例输入 123470 371 10069 11 2 样例输出 13 来源 NOIP 2005 解决 123456789N=1010T,M=map(int,input().split())f = [0 for _ in range(N)]for i in range(0, M): v,w=map(int,input().split()) for j in range(T, v - 1, -1): f[j] = max(f[j], f[j - v] + w)print(f[T]) 简单的整数划分问题描述 将正整数n 表示成一系列正整数之和，n=n1+n2+…+nk, 其中n1&gt;=n2&gt;=…&gt;=nk&gt;=1 ，k&gt;=1 。正整数n 的这种表示称为正整数n 的划分。正整数n 的不同的划分个数称为正整数n 的划分数。 输入 标准的输入包含若干组测试数据。每组测试数据是一个整数N(0 &lt; N &lt;= 50)。 输出 对于每组测试数据，输出N的划分数。 样例输入 15 样例输出 17 提示 5, 4+1, 3+2, 3+1+1, 2+2+1, 2+1+1+1, 1+1+1+1+1 解决 1234567891011121314151617def f(x,y): if y == 1: return 1 elif y &lt;= 0: return 0 elif x &lt; y: return 0 else: return(f(x - 1,y - 1) + f(x - y,y))while True: try: n = int(input()) s = 1 for i in range(n): s = s + f(n,i) print(s) except EOFError: break","link":"/2022/03/20/%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A2%98%E7%9B%AE/"},{"title":"二叉树中的最大路径和","text":"题目路径被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中至多出现一次。该路径至少包含一个节点，且不一定经过根节点。 路径和 是路径中各节点值的总和。 给你一个二叉树的根节点 root ，返回其 最大路径和 。 输入：root = [-10,9,20,null,null,15,7]输出：42解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42 递归林小鹿 路径 在这道题目中，路径是指从树中某个节点开始，沿着树中的边走，走到某个节点为止，路过的所有节点的集合。路径的权值和是指路径中所有节点的权值的总和。 对于一棵树，我们可以将其划分为很多的子树，如下图所示，虚线矩形围起来的子树。我们把这颗子树的蓝色节点称为该子树最高节点。用最高节点可以将整条路径分为两部分：从该节点向左子树延伸的路径，和从该节点向右子树延伸的部分。 递归遍历整棵树，递归时维护从每个子树从最高节点开始往下延伸的最大路径和。 对于每个子树的最高节点，递归计算完左右子树后，我们将左右子树维护的两条最大路径，和该点拼接起来，就可以得到以这个点为最高节点子树的最大路径。（这条路径一定是：左子树路径-&gt;最高节点-&gt;右子树路径） 然后维护从这个点往下延伸的最大路径：从左右子树的路径中选择权值大的一条延伸即可。（只能从左右子树之间选一条路径） 最后整颗树的最大路径和为: 根节点值+左子树最大路径和+右子树最大路径和，即left_max + right_max + root-&gt;val 注意 如果某条路径之和小于0，那么我们选择不走该条路径，因此其路径之和应和0之间取最大值。 时间复杂度分析: 每个节点仅会遍历一次，所以时间复杂度是 O(n)。 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: int res = INT_MIN; int maxPathSum(TreeNode* root) { dfs(root); return res; } int dfs(TreeNode* root){ if(!root) return 0; int left = max(0, dfs(root-&gt;left)), right = max(0, dfs(root-&gt;right)); res = max(res, root-&gt;val + left + right); return root-&gt;val + max(left, right); }}; DFS-非自顶而下作者：eh-xing-qing总结得实在好 非自顶而下 这类题目一般解题思路如下：设计一个辅助函数maxpath，调用自身求出以一个节点为根节点的左侧最长路径left和右侧最长路径right，那么经过该节点的最长路径就是left+right接着只需要从根节点开始dfs，不断比较更新全局变量即可 12345678910int res=0;int maxPath(TreeNode *root) //以root为路径起始点的最长路径{ if (!root) return 0; int left=maxPath(root-&gt;left); int right=maxPath(root-&gt;right); res = max(res, left + right + root-&gt;val); //更新全局变量 return max(left, right); //返回左右路径较长者} 这类题型DFS注意点 left,right代表的含义要根据题目所求设置，比如最长路径、最大路径和等等 全局变量res的初值设置是0还是INT_MIN要看题目节点是否存在负值,如果存在就用INT_MIN，否则就是0 注意两点之间路径为1，因此一个点是不能构成路径的 1234567891011121314151617181920class Solution{public: int res = INT_MIN; //注意节点值可能为负数，因此要设置为最小值 int maxPathSum(TreeNode *root) { maxPath(root); return res; } int maxPath(TreeNode *root) //以root为路径起始点的最长路径 { if (!root) return 0; int left = max(maxPath(root-&gt;left), 0); int right = max(maxPath(root-&gt;right), 0); res = max(res, left + right + root-&gt;val); //比较当前最大路径和与左右子树最长路径加上根节点值的较大值，更新全局变量 return max(left + root-&gt;val, right + root-&gt;val); //返回左右子树较长的路径加上根节点值 }};","link":"/2022/07/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"},{"title":"二叉树的下一个结点","text":"题目给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 分析二叉树的下一个节点，一共有以下情况： 二叉树为空，则返回空； 节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点； 节点不是根节点。如果该节点是其父节点的左孩子，则返回父节点；否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果。 12345678910111213141516171819202122232425262728/*struct TreeLinkNode { int val; struct TreeLinkNode *left; struct TreeLinkNode *right; struct TreeLinkNode *next; //父节点 TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) { }};*/class Solution {public: TreeLinkNode* GetNext(TreeLinkNode* pNode) { if(pNode-&gt;right) { //如果有右子树，则找右子树的最左节点 TreeLinkNode *p = pNode-&gt;right; while(p-&gt;left) p = p-&gt;left; return p; } TreeLinkNode *p = pNode; while(p-&gt;next) { //没右子树，则找第一个当前节点是父节点左孩子的节点 if(p-&gt;next-&gt;left == p) return p-&gt;next; p = p-&gt;next; } return nullptr; //退到了根节点仍没找到，则返回null }}; 复习 前序遍历：F, B, A, D, C, E, G, I, H中序遍历：A, B, C, D, E, F, G, H, I后序遍历：A, C, E, D, B, H, I, G, F层次遍历：F, B, G, A, D, I, C, E, H","link":"/2022/07/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9/"},{"title":"二叉树的最近公共祖先","text":"题目给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出：3解释：节点 5 和节点 1 的最近公共祖先是节点 3 。 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出：5解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。 输入：root = [1,2], p = 1, q = 2输出：1 好笨啊，看看题解吧 递归Moment 当我们用递归去做这个题时不要被题目误导，应该要明确一点这个函数的功能有三个：给定两个节点 p 和 q 如果 p 和 q 都存在，则返回它们的公共祖先； 如果只存在一个，则返回存在的一个； 如果 p 和 q 都不存在，则返回NULL 本题说给定的两个节点都存在，那自然还是能用上面的函数来解决 具体思路 如果当前结点 root 等于 NULL，则直接返回 NULL 如果 root 等于 p 或者 q ，那这棵树一定返回 p 或者 q 然后递归左右子树，因为是递归，使用函数后可认为左右子树已经算出结果，用 left 和 right 表示 此时若left为空，那最终结果只要看 right；若 right 为空，那最终结果只要看 left 如果 left 和 right 都非空，因为只给了 p 和 q 两个结点，都非空，说明一边一个，因此 root 是他们的最近公共祖先 如果 left 和 right 都为空，则返回空（其实已经包含在前面的情况中了） 时间复杂度是 O(n)：每个结点最多遍历一次或用主定理，空间复杂度是 O(n)：需要系统栈空间 123456789101112131415161718192021class Solution {public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(root == NULL) return NULL; if(root == p || root == q) return root; TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q); if(left == NULL) return right; if(right == NULL) return left; if(left &amp;&amp; right) // p和q在两侧 return root; return NULL; // 必须有返回值 }}; 暴力old8 一次dfs维护出每个点的深度和父亲，查询时先将两点定到相同深度，之后一起往上跳。整体复杂度为O(nlogn)。 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { map&lt;TreeNode*, int&gt; vis; map&lt;TreeNode*, TreeNode*&gt; pre; function&lt;void(TreeNode*, TreeNode*, int)&gt; dfs = [&amp;](TreeNode* fa, TreeNode* rt, int dep) { vis[rt] = dep; pre[rt] = fa; if (rt-&gt;left) dfs(rt, rt-&gt;left, dep + 1); if (rt-&gt;right) dfs(rt, rt-&gt;right, dep + 1); }; dfs(NULL, root, 1); if (p == q) return p; while (vis[p] &gt; vis[q] &amp;&amp; pre[p] != NULL) p = pre[p]; while (vis[p] &lt; vis[q] &amp;&amp; pre[q] != NULL) q = pre[q]; while (p != q) { p = pre[p]; q = pre[q]; } return p; }}; 倍增优化DP维护f(u, k)表示u节点的第$2^k$个祖先，更新时一次dfs，f(u, k + 1) = f(f(u, k), k)，查询的时候类似暴力解法，不过向上跳可以跳得步伐大很多。对于本题预处理复杂度为O(nlogn)，查询复杂度为O(2logn)。 123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { const int maxf = 22; map&lt;TreeNode*, int&gt; vis; map&lt;TreeNode*, TreeNode*&gt; pre[maxf]; function&lt;void(TreeNode*, TreeNode*, int)&gt; dfs = [&amp;](TreeNode* fa, TreeNode* rt, int dep) { vis[rt] = dep; pre[0][rt] = fa; for (int i = 0; (1 &lt;&lt; i) &lt;= vis[fa] &amp;&amp; i &lt; maxf; i++) { pre[i + 1][rt] = pre[i][pre[i][rt]]; } if (rt-&gt;left) dfs(rt, rt-&gt;left, dep + 1); if (rt-&gt;right) dfs(rt, rt-&gt;right, dep + 1); }; dfs(NULL, root, 1); if (vis[p] &lt; vis[q]) swap(p, q); for (int i = maxf - 1; i &gt;= 0; i--) { if (vis[p] &gt;= (1 &lt;&lt; i) &amp;&amp; vis[pre[i][p]] &gt;= vis[q]) p = pre[i][p]; if (p == q) return p; } for (int i = maxf - 1; i &gt;= 0; i--) { if (vis[p] &gt;= (1 &lt;&lt; i) &amp;&amp; pre[i][p] != pre[i][q]) { p = pre[i][p]; q = pre[i][q]; } } return pre[0][p]; }}; 思考Krahets 何为最近公共祖先？ 设节点 root 为节点 p，q 的某公共祖先，若其左子节点 root.left 和右子节点 root.right 都不是 p，q的公共祖先，则称 root 是“最近的公共祖先” 根据以上定义，若 root 是 p，q 的最近最近公共祖先，则只可能为以下的情况之一： p，q 位于 root 异侧（分别在左右子树中） p = root，且 q 在 root 的左或右子树中 q = root，且 p 在 root 的左或右子树中 比如，上图中的7，8，它们的最近公共祖先为3，因为5不是8的祖先，1不为7的祖先。 递归解析 终止条件 当越过叶节点，直接返回null； 当root等于p，q，则直接返回root； 递归工作 开启递归左子节点，返回值记为left； 开启递归右子节点，返回值即为right； 返回值： 当left和right同为空，说明root的左/右子树中均不含p，q，则返回null； 当left和right同不为空，说明p，q分别位于root异侧，因此root为最近公共祖先，返回root； 当left为空，right不为空，p，q都不在root的左子树中，直接返回right，具体有两种情况： p，q其中一个在root的右子树中，此时right指向p（假设为p）； p，q两节点都在root的右子树中，此时的right指向最近公共祖先节点； 当left不为空，right为空，与前一种情况同理 12345678910111213141516171819202122232425class Solution {public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(root == nullptr || root == p || root == q) return root; TreeNode *left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode *right = lowestCommonAncestor(root-&gt;right, p, q); if(left == nullptr &amp;&amp; right == nullptr) return nullptr; // 1. if(left == nullptr) return right; // 3. if(right == nullptr) return left; // 4. return root; // 2. if(left != null and right != null) }};/*观察发现， 情况 1. 可合并至 3. 和 4. 内*/// class Solution {// public:// TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {// if(root == nullptr || root == p || root == q) return root;// TreeNode *left = lowestCommonAncestor(root-&gt;left, p, q);// TreeNode *right = lowestCommonAncestor(root-&gt;right, p, q);// if(left == nullptr) return right;// if(right == nullptr) return left;// return root;// }// }; 时间复杂度 O(N) ： 其中 NN 为二叉树节点数；最差情况下，需要递归遍历树的所有节点。 空间复杂度 O(N) ： 最差情况下，递归深度达到 N ，系统使用 O(N) 大小的额外空间。","link":"/2022/07/14/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"},{"title":"反转链表","text":"题目给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 输入：head = [1,2,3,4,5]输出：[5,4,3,2,1] 递归路漫漫我不畏 使用递归函数，一直递归到链表的最后一个结点，该结点就是反转后的头结点，记作 cur 此后，每次函数在返回的过程中，让当前结点的下一个结点的 next 指针指向当前节点 同时让当前结点的 next 指针指向 NULL ，从而实现从链表尾部开始的局部反转 当递归函数全部出栈后，链表反转完成 123456789101112131415class Solution{public: ListNode *reverseList(ListNode *head) { if (head == NULL || head-&gt;next == NULL) { return head; } ListNode *cur = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = NULL; return cur; }}; 简单的双指针 定义双指针：pre 和 cur 局部反转：pre-&gt;next=cur pre 和 cur 同时右移一个位置 循环上述过程，直至 pre 到达链表尾部 12345678910111213141516class Solution{public: ListNode *reverseList(ListNode *head) { ListNode *cur = NULL, *pre = head; while (pre != NULL) { ListNode *tmp = pre-&gt;next; pre-&gt;next = cur; cur = pre; pre = tmp; } return cur; }}; 较复杂的双指针 定义指针 cur ，初始化为 head 局部反转：head-&gt;next 的 next 指向 cur cur 和 head-&gt;next 同时右移一个位置 循环上述过程，直至 cur 到达链表尾部 1234567891011121314151617181920class Solution{public: ListNode *reverseList(ListNode *head) { if (head == NULL) { return NULL; } ListNode *cur = head; while (head-&gt;next != NULL) { ListNode *t = head-&gt;next-&gt;next; head-&gt;next-&gt;next = cur; cur = head-&gt;next; head-&gt;next = t; } return cur; }};","link":"/2022/07/11/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"title":"向量","text":"简介向量vector是可以改变其大小的线性序列容器，像数组一样，向量使用连续的空间存储元素，这表明向量可以像数组一样通过下标来访问其元素，但不同于数组的是，向量的大小可以动态变化。 12345678910111213141516171819202122232425262728293031323334//常用操作#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;using namespace std;vector&lt;int&gt; myVector;int main(){ for (int i = 0; i &lt; 5; ++i) { myVector.push_back(i); //从尾部逐一添加元素 } myVector.insert(myVector.begin(), 3, 15); //头部插入3个15 myVector.pop_back(); for (int i = 0; i &lt; myVector.size(); ++i) { printf(&quot;%d &quot;, myVector[i]); } printf(&quot;\\n&quot;); printf(&quot;the 5th element of myVector:%d\\n&quot;, myVector[4]); printf(&quot;the size of myVector:%d\\n&quot;, myVector.size()); myVector.erase(myVector.begin() + 5, myVector.end()); //删除第5后续的元素 vector&lt;int&gt;::iterator it; //定义迭代器 for (it = myVector.begin(); it != myVector.end(); it++) { printf(&quot;%d &quot;, *it); //遍历向量 } printf(&quot;\\n&quot;); myVector.clear(); return 0;} 123415 15 15 0 1 2 3the 5th element of myVector:1the size of myVector:715 15 15 0 1 向量的应用完数与盈数一个数如果恰好等于它的各因子(该数本身除外)之和，如：6=3+2+1。则称其为“完数”；若因子之和大于该数，则称其为“盈数”。 求出2到60之间所有“完数”和“盈数”。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;using namespace std;vector&lt;int&gt; numberE; //完数vector&lt;int&gt; numberG; //盈数int Sum(int x){ int sum = 0; for (int i = 1; i &lt; x; ++i) { if (x % i == 0) { sum += i; } } return sum;}int main(){ for (int i = 2; i &lt;= 60; ++i) { if (i == Sum(i)) { numberE.push_back(i); } else if (i &lt; Sum(i)) { numberG.push_back(i); } } printf(&quot;E:&quot;); for (int i = 0; i &lt; numberE.size(); ++i) { printf(&quot;%d &quot;, numberE[i]); } printf(&quot;\\n&quot;); printf(&quot;G:&quot;); for (int i = 0; i &lt; numberG.size(); ++i) { printf(&quot;%d &quot;, numberG[i]); } printf(&quot;\\n&quot;); return 0;} 12E:6 28G:12 18 20 24 30 36 40 42 48 54 56 60","link":"/2022/06/03/%E5%90%91%E9%87%8F/"},{"title":"堆排序","text":"什么是堆如果有一个关键码的集合$K={k_0,k_1,k_2,…,k_{n-1}}$，把它的所有元素按完全二叉树的顺序存储方式存储在一个一维数组中，并满足$ki&lt;=k_{2i+1}$且$ki&lt;=k_{2i+2}$（或满足$ki&gt;=k_{2i+1}且ki&gt;=k_{2i+2}$），其中$i=0,1,2,…$则称该集合为堆。 小堆：对于一棵完全二叉树，满足任一节点都比其孩子节点小，也就是将根结点为最小元素的堆叫做小堆，也叫最小堆或小根堆。 大堆：对于一棵完全二叉树，满足任一节点都比其孩子节点大，也就是将根结点为最大元素的堆叫做大堆，也叫最大堆或大根堆。 堆的性质 堆中某个结点的值总是不大于或不小于其父结点的值。 堆总是一棵完全二叉树。 堆的向下调整假设：节点的左右子树都是堆（大/小），但是其自身不是堆，可以通过一次向下的调整来将其变换成一个堆。以调整至大堆为例 从根结点处开始，选出左右孩子中值较大的孩子。 让较大的孩子与其父亲进行比较。 若较大的孩子比父亲大，则该孩子与其父亲的位置进行交换。并将原来小的孩子的位置当成父亲继续向下进行调整，直到调整到叶子结点为止。 若较大的孩子比父亲小，则不需处理了，调整完成，整个树已经是大堆了。12345678910111213141516171819202122def sift(li,low,high): ''' :param li:列表 :param low:堆的根节点位置 :param high:堆的最后一个元素的位置 :return: ''' i = low #父节点 j=2*i+1 #左孩子 tmp=li[low] #堆顶存储 while j&lt;=high: #只要左孩子没越界 if j+1&lt;=high and li[j+1]&gt;li[j]: #如果有右孩子,并且右孩子比较大,别忘了前提需要保证j+1位置不越界 j=j+1 #j指向右孩子位置 if li[j]&gt;tmp: li[i]=li[j] i=j #往下看一层 j=2*i+1 else: #如果tmp更大,把tmp放到i的位置上 li[i]=tmp break else: #别忘了考虑,如果当堆顶元素的左孩子已经越界,直接将其存入li[i] li[i]=tmp 全过程 建立堆，得到堆顶元素，为最大元素12345678910111213141516171819202122232425262728293031323334def sift(li,low,high): ''' :param li:列表 :param low:堆的根节点位置 :param high:堆的最后一个元素的位置 :return: ''' i = low #父节点 j=2*i+1 #左孩子 tmp=li[low] #堆顶存储 while j&lt;=high: #只要左孩子没越界 if j+1&lt;=high and li[j+1]&gt;li[j]: #如果有右孩子,并且右孩子比较大,别忘了还要保证j+1位置不越界 j=j+1 #j指向右孩子位置 if li[j]&gt;tmp: li[i]=li[j] i=j #往下看一层 j=2*i+1 else: # 不管怎么样都得把这个空补上，直接脱到最后执行 break li[i]=tmpdef heapCreate(li): n=len(li) for i in range((n-2)//2,-1,-1): #i表示建堆的时候调整的部分根下标 sift(li,i,n-1) #堆建立完成# 验证import randomli=[i for i in range(16)]random.shuffle(li)print(li)heapCreate(li)print(li) 12[9, 13, 15, 6, 14, 8, 12, 7, 11, 1, 2, 3, 4, 10, 5, 0][15, 14, 12, 11, 13, 8, 10, 7, 6, 1, 2, 3, 4, 9, 5, 0] 去掉堆顶，将堆最后一个元素放到堆顶，实质上交换了堆顶元素和堆尾元素，但是需要注意交换后的堆尾元素并不是原来的堆顶元素，而应当是原堆尾元素的左边紧挨着的那一个元素，所以接下来的调整传入的堆尾索引也就是high为i-1，接着可通过一次调整重新使得堆有序 堆顶元素为第二大元素 重复步骤2，直到堆空12345678910111213141516171819202122232425262728293031323334353637def sift(li,low,high): ''' :param li:列表 :param low:堆的根节点位置 :param high:堆的最后一个元素的位置 :return: ''' i = low #父节点 j=2*i+1 #左孩子 tmp=li[low] #堆顶存储 while j&lt;=high: #只要左孩子没越界 if j+1&lt;=high and li[j+1]&gt;li[j]: #如果有右孩子,并且右孩子比较大,别忘了还要保证j+1位置不越界 j=j+1 #j指向右孩子位置 if li[j]&gt;tmp: li[i]=li[j] i=j #往下看一层 j=2*i+1 else: # 不管怎么样都得把这个空补上，直接脱到最后执行 break li[i]=tmpdef heapSort(li): n=len(li) for i in range((n-2)//2,-1,-1): #i表示建堆的时候调整的部分根下标 sift(li,i,n-1) #堆建立完成 for i in range(n-1,-1,-1): #i指向当前堆的最后一个元素 li[0],li[i]=li[i],li[0] #先交换堆顶元素和堆尾元素 sift(li,0,i-1) #i-1为新的high# 验证import randomli=[i for i in range(16)]random.shuffle(li)print(li)heapSort(li)print(li) 12[7, 5, 11, 12, 14, 0, 15, 4, 13, 9, 6, 8, 10, 2, 1, 3][0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] 时间复杂度分为两部分，第一部分向下调整 1234567891011121314def sift(li,low,high): i = low j=2*i+1 tmp=li[low] while j&lt;=high: if j+1&lt;=high and li[j+1]&gt;li[j]: j=j+1 if li[j]&gt;tmp: li[i]=li[j] i=j j=2*i+1 else: break li[i]=tmp 这一部分，相当于走了一遍完全二叉树的深度，设元素个数为n，深度即为log(n+1) 相当于logn （根据深度为h，结点数最多为$2^{h-1}$） 12345678def heapSort(li): n=len(li) for i in range((n-2)//2,-1,-1): sift(li,i,n-1) #堆建立完成 for i in range(n-1,-1,-1): li[0],li[i]=li[i],li[0] sift(li,0,i-1) 第二部分为建堆，逐个出数，外层循环部分均为$n$，而内层为调整函数，所以总的时间复杂度为$O(nlogn)$ C++版本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;void max_heapify(vector&lt;int&gt;&amp; nums, int start, int end){ int dad = start; int son = dad * 2 + 1; while (son &lt;= end) { if (son + 1 &lt;= end &amp;&amp; nums[son] &lt; nums[son + 1]) { son++; } if (nums[dad] &gt; nums[son]) { return; } else { swap(nums[dad], nums[son]); dad = son; son = dad * 2 + 1; } }}void heap_sort(vector&lt;int&gt;&amp; nums, int len){ for (int i = len / 2 - 1; i &gt;= 0; i--) { max_heapify(nums, i, len - 1); } for (int i = len - 1; i &gt; 0; i--) { swap(nums[0], nums[i]); max_heapify(nums, 0, i - 1); }}int main() { int num; vector&lt;int&gt; int_array; while (cin &gt;&gt; num) { int_array.push_back(num); if (cin.get() == '\\n')break; } int len = int_array.size(); heap_sort(int_array, len); for (int n : int_array)cout &lt;&lt; n &lt;&lt; &quot; &quot;; return 0;} topk问题现在有n个数，设计算法得到前k大的数（k&lt;n） 解决思路 排序后切片 O(nlogn) 冒泡、插入、选择排序 O(kn) 堆排序 O(klogn) 取列表前k个元素建立一个小根堆，堆顶就是目前第k大的数；依次向后遍历原列表，对于列表中的元素，如果小于堆顶，则忽略该元素；如果大于堆顶，则将堆顶更换为该元素，并且对堆进行一次调整；遍历列表所有元素后，倒序弹出堆顶。 比如 6 8 1 9 3 0 7 2 4 5 拿出前五个数，建立一个小根堆 剩下 0 7 2 4 5 0&lt;1 0舍 1不动 剩下 7 2 4 5 7&gt;1 1舍 7上 剩下 2 4 5 7&gt;3 小根堆调整 7、3对调 剩下 2 4 5 2&lt;3 2舍 3不动 剩下4 5 4&gt;3 3舍 4上 剩下5 5&gt;4 4舍5上 具体怎么做？基本就是小根堆版本 12345678910111213141516171819202122232425262728293031323334353637383940def sift(li,low,high): ''' :param li:列表 :param low:堆的根节点位置 :param high:堆的最后一个元素的位置 :return: ''' i = low #父节点 j=2*i+1 #左孩子 tmp=li[low] #堆顶存储 while j&lt;=high: #只要左孩子没越界 if j+1&lt;=high and li[j+1]&lt;li[j]: #如果有右孩子,并且右孩子比较小,别忘了还要保证j+1位置不越界 j=j+1 #j指向右孩子位置 if li[j]&lt;tmp: li[i]=li[j] i=j #往下看一层 j=2*i+1 else: # 不管怎么样都得把这个空补上，直接脱到最后执行 break li[i]=tmpdef topk(li,k): heap=li[0:k] #取前k个数 for i in range((k-2)//2,-1,-1): sift(heap,i,k-1) #1.小根堆建立完成 for i in range(k,len(li)): if li[i]&gt;heap[0]: heap[0]=li[i] sift(heap,0,k-1) #2.遍历列表里剩下的所有元素完成 for i in range(k-1,-1,-1): #i指向当前堆的最后一个元素 heap[0],heap[i]=heap[i],heap[0] #先交换堆顶元素和堆尾元素 sift(heap,0,i-1) #i-1为新的high #3.挨个出数完成 return heapli=[6,8,1,9,3,0,7,2,4,5]print(li)print(topk(li,5))","link":"/2022/05/14/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"title":"岛屿数量","text":"题目给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 输入：grid = [ [“1”,”1”,”1”,”1”,”0”], [“1”,”1”,”0”,”1”,”0”], [“1”,”1”,”0”,”0”,”0”], [“0”,”0”,”0”,”0”,”0”]]输出：1 输入：grid = [ [“1”,”1”,”0”,”0”,”0”], [“1”,”1”,”0”,”0”,”0”], [“0”,”0”,”1”,”0”,”0”], [“0”,”0”,”0”,”1”,”1”]]输出：3 DFS123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: int count = 0; int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) { for(int i = 0; i &lt; grid.size(); i++) { for(int j = 0; j &lt; grid[0].size(); j++) { if(grid[i][j] == '1') { count++; dfs(grid, i, j); } } } return count; } void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int r, int c) { //判断 base case //如果坐标（r,c）超出了网格范围，直接返回 if(!isArea(grid, r, c)) return; //如果这个格子不是岛屿，直接返回 if (grid[r][c] != '1') return; grid[r][c] = 2; //将格子标记为2 //访问上、下、左、右四个相邻结点 dfs(grid, r-1, c); dfs(grid, r+1, c); dfs(grid, r, c-1); dfs(grid, r, c+1); } //判断坐标（r,c）是否在网格中 bool isArea(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int r, int c) { return (0 &lt;= r &amp;&amp; r &lt; grid.size() &amp;&amp; 0 &lt;= c &amp;&amp; c &lt; grid[0].size()); }}; 网格类DFS框架二叉树的DFS遍历有两要素 访问邻接节点，对于二叉树而言，邻接节点即左子节点和右子节点两个。 判断base case，一般来说二叉树遍历的base case是root==null，其有两层含义，一方面，这表示root指向的子树为空，不需要再往下遍历了，另一方面，在root==null的时候及时返回，可以让后面的root.left和root.right操作不会出现空指针异常。 对于网格类DFS问题，参考二叉树的DFS两要素，写出其两要素 上下左右四个邻接节点，如图1 网格DFS中的base case是什么？网格中不要继续遍历，grid[r][c]会出现数组越界，即超出了网格范围的格子，这跟二叉树的遍历方法是一样的，先递归调用，发现root==null再返回。 如何避免重复的遍历？ 与二叉树DFS最大不同之处在于，遍历中可能遇到遍历过的节点。 可以标记已经遍历过的节点，我们想在所有值为1的格子上DFS遍历，每走过一个格子，就把格子值改为2，当再遇到值为2的格子后，就知道已经遍历过了。 123456789101112131415161718192021void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int r, int c) { //判断 base case //如果坐标（r,c）超出了网格范围，直接返回 if(!isArea(grid, r, c)) return; //如果这个格子不是岛屿，直接返回 if (grid[r][c] != '1') return; grid[r][c] = 2; //将格子标记为2 //访问上、下、左、右四个相邻结点 dfs(grid, r-1, c); dfs(grid, r+1, c); dfs(grid, r, c-1); dfs(grid, r, c+1); } //判断坐标（r,c）是否在网格中 bool isArea(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int r, int c) { return (0 &lt;= r &amp;&amp; r &lt; grid.size() &amp;&amp; 0 &lt;= c &amp;&amp; c &lt; grid[0].size()); } 并查集我们也可以使用并查集代替搜索。 扫描网格，判断其上方以及左方是否为1以及自身是否为1，符合的话并入集合中； 扫描完后，进行第二次合并，查代表元素，即连通块（陆地）的数量。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution {public: int n, m; vector&lt;int&gt; fa; void init(int n) { fa = vector&lt;int&gt;(n); for (int i = 0; i &lt; n; i ++) { fa[i] = i; } } int get(int x) { return x == fa[x] ? x : fa[x] = get(fa[x]); } void merge(int x, int y) { fa[get(x)] = get(y); } int reflect(int x, int y) { return x * m + y; } int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) { if (grid.empty()) return 0; n = grid.size(), m = grid[0].size(); init(n * m); for (int i = 0 ; i &lt; n; i ++) { for (int j = 0; j &lt; m; j ++) { if (grid[i][j] == '0') continue; if (i &amp;&amp; grid[i - 1][j] == '1') merge(reflect(i, j), reflect(i - 1, j)); if (j &amp;&amp; grid[i][j - 1] == '1') merge(reflect(i, j), reflect(i, j - 1)); } } int ans = 0; for (int i = 0; i &lt; n; i ++) { for (int j = 0; j &lt; m; j ++) { if (grid[i][j] == '0') continue; else if (fa[reflect(i, j)] == reflect(i, j)) { ans ++; } } } return ans; }};","link":"/2022/07/17/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"},{"title":"希尔排序","text":"回顾插入排序 12345678def insertSort(li): for i in range(1,len(li)): #i表示摸到的牌的下标,注意循环从1开始,因为手里的牌是0 tmp=li[i] j=i-1 #j表示手里的牌的下标 while j&gt;=0 and li[j]&gt;tmp: #如果手里的牌比tmp小或者手里已经没有牌了,结束循环 li[j+1]=li[j] j-=1 li[j+1]=tmp 希尔排序现在，希尔排序在插入排序的基础上，设置了间隔gap，实现了分组插入排序 首先取一个整数d1=n/2，将元素分为d1个组，每组相邻两元素之间间距为d1，在个组内进行直接插入排序 取第二个整数d2=d1/2，重复上述分组排序过程，直到di=1，即所有元素在同一组内进行直接插入排序 希尔排序每趟并不能使某些元素有序，而是使整体数据越来越接近有序；最有一趟使得所有数据有序。 1234567891011121314151617181920212223def insertSort_gap(li,gap): for i in range(gap,len(li)): #i表示摸到的牌的下标,注意循环从gap开始,因为手里的牌是0~(gap-1) tmp=li[i] j=i-gap #j表示手里的牌的下标 while j&gt;=0 and li[j]&gt;tmp: #如果手里的牌比tmp小或者手里已经没有牌了,结束循环 li[j+gap]=li[j] j-=gap li[j+gap]=tmpdef shell_sort(li): d=len(li)//2 while d&gt;=1: insertSort_gap(li,d) d//=2# 验证import randomli=list(range(10))random.shuffle(li)print(li)shell_sort(li)print(li) 12[1, 9, 8, 5, 2, 0, 4, 6, 7, 3][0, 1, 2, 3, 4, 5, 6, 7, 8, 9]","link":"/2022/05/12/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"},{"title":"归并排序","text":"基本思路一次归并 假设左右部分都已经排好序 123456789101112131415161718192021222324def merge(li,low,mid,high): i=low j=mid+1 tmp=[] while i&lt;=mid and j&lt;=high: if li[i]&lt;li[j]: tmp.append(li[i]) i+=1 else: tmp.append(li[j]) j+=1 while i&lt;=mid: tmp.append(li[i]) i+=1 while j&lt;=high: tmp.append(li[j]) j+=1 li[low:high+1]=tmp# 验证li=[2,4,6,8,1,3,5,7]print(li)merge(li,0,3,7)print(li) 12[2, 4, 6, 8, 1, 3, 5, 7][1, 2, 3, 4, 5, 6, 7, 8] 先分解 将列表越分越小，直至分成一个元素，使用递归 剩下合并其实就是上面的一次归并 12345678910111213141516171819202122232425262728293031323334def merge(li,low,mid,high): i=low j=mid+1 tmp=[] while i&lt;=mid and j&lt;=high: if li[i]&lt;li[j]: tmp.append(li[i]) i+=1 else: tmp.append(li[j]) j+=1 while i&lt;=mid: tmp.append(li[i]) i+=1 while j&lt;=high: tmp.append(li[j]) j+=1 li[low:high+1]=tmpdef merge_sort(li,low,high): if low&lt;high: #至少两个元素,递归 mid=(low+high)//2 merge_sort(li,low,mid) merge_sort(li,mid+1,high) merge(li,low,mid,high)# 验证import randomli=list(range(16))random.shuffle(li)print(li)merge_sort(li,0,len(li)-1)print(li) 12[14, 3, 5, 11, 6, 9, 8, 7, 4, 15, 0, 12, 1, 10, 13, 2][0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] 为了更加直观地看到分解以及合并的递归过程，我们对merge_sort()函数稍作修改 1234567def merge_sort(li,low,high): if low&lt;high: #至少两个元素,递归 mid=(low+high)//2 merge_sort(li,low,mid) merge_sort(li,mid+1,high) print(li[low:high+1]) merge(li,low,mid,high) 1234567891011121314151617[10, 9, 8, 13, 14, 4, 1, 2, 7, 6, 15, 5, 11, 0, 3, 12][10, 9][8, 13][9, 10, 8, 13][14, 4][1, 2][4, 14, 1, 2][8, 9, 10, 13, 1, 2, 4, 14][7, 6][15, 5][6, 7, 5, 15][11, 0][3, 12][0, 11, 3, 12][5, 6, 7, 15, 0, 3, 11, 12][1, 2, 4, 8, 9, 10, 13, 14, 0, 3, 5, 6, 7, 11, 12, 15][0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] C++1234567891011121314151617181920212223242526272829303132333435363738394041#define _CRT_SECURE_NO_WARNINGS#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; t;void mergesort(vector&lt;int&gt;&amp; a, int low, int high) { if (low &gt;= high) return; int mid = (low + high) &gt;&gt; 1; mergesort(a, low, mid); mergesort(a, mid + 1, high); int i = low, j = mid + 1, idx = low; while (i &lt;= mid || j &lt;= high) { if (i &lt;= mid &amp;&amp; j &lt;= high) { if (a[i] &lt;= a[j]) t[idx] = a[i++]; else t[idx] = a[j++]; } else if (i &lt;= mid) { t[idx] = a[i++]; } else { t[idx] = a[j++]; } idx++; } for (int k = low; k &lt;= high; k++) a[k] = t[k];}int main() { int num; vector&lt;int&gt; a; while (cin &gt;&gt; num) { a.push_back(num); if (cin.get() == '\\n')break; } t.resize(a.size()); mergesort(a, 0, a.size() - 1); for (int n : a)cout &lt;&lt; n &lt;&lt; &quot; &quot;; return 0;} 时间复杂度从图入手，每一层相当于把整个列表遍历一遍，O(n)；总共logn层，所以合并也就是一半部分的时间复杂度为O(nlogn)。 还有因为归并排序不是”原地排序”，我们开了一个临时空间tmp，所以空间复杂度为O(n)。","link":"/2022/05/15/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"title":"数组中的第K个最大元素","text":"题目给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 输入：[3,2,3,1,2,4,5,5,6] 和 k = 4输出：4 暴力求解1234567891011121314#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution {public: int findKthLargest(vector&lt;int&gt; &amp;nums, int k) { int size = nums.size(); sort(begin(nums), end(nums)); return nums[size - k]; }}; 大顶堆调用priority_queue 12345678910111213class Solution{public: int findKthLargest(vector&lt;int&gt; &amp;nums, int k) { priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; maxHeap; for (int x : nums) maxHeap.push(x); for (int _ = 0; _ &lt; k - 1; _++) maxHeap.pop(); return maxHeap.top(); }}; NB solution 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution{public: void shiftDown(vector&lt;int&gt; &amp;nums, int i, int len) { int root = i; while (root &lt; len) { int tmp = root; int left = 2 * root + 1, right = 2 * root + 2; if (left &lt; len &amp;&amp; nums[root] &lt; nums[left]) { root = left; } if (right &lt; len &amp;&amp; nums[root] &lt; nums[right]) { root = right; } if (root == tmp) { break; } swap(nums[tmp], nums[root]); } } void buildHeap(vector&lt;int&gt; &amp;nums) { int n = nums.size(); for (int i = n / 2 - 1; i &gt;= 0; i--) { shiftDown(nums, i, n); } } int findKthLargest(vector&lt;int&gt; &amp;nums, int k) { //构建最大堆 buildHeap(nums); int n = nums.size(); // pop k-1个元素 for (int i = n - 1; i &gt; n - k; i--) { swap(nums[0], nums[i]); shiftDown(nums, 0, i); } return nums[0]; }}; 优先队列其内部可以看作是一棵由数组模拟的完全二叉树，对于这棵树的每一个结点来说，自身的优先级不低于左右孩子的优先级，所以其功能就是拿出优先级最大的元素，如何简单使用C++中内置容器priority_queue？首先引出头文件&lt;queue&gt;，定义一个默认的优先队列（大顶堆）priority_queue&lt;int&gt; que;即值越大的元素优先级越高先出队。 que.size() 元素数量 que.push(x) 插入x que.pop() 删除优先级最高的元素 que.top() 访问优先级最高的元素（堆顶元素） que.empty() 判空 对于优先队列的操作，插入删除的时间复杂度为对数级，访问堆顶元素时间复杂度为常数级，所以比较适合动态调整，获得极值。 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;//大顶堆int main(){ priority_queue&lt;int&gt; que; que.push(7); que.push(5); que.push(-2); que.push(1); que.push(6); cout &lt;&lt; que.size() &lt;&lt; endl; while (!que.empty()) { cout &lt;&lt; que.top() &lt;&lt; &quot; &quot;; que.pop(); } cout &lt;&lt; endl; return 0;} 如何定义一个小顶堆？优先队列除了第一个数据类型以外，还有其他两个模板参数：底层顺序结构类型（默认是vector，也可使用queue或者array），第三个参数是一个仿函数，提供优先队列权值比较方法。 12priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; q; //大顶堆priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; //小顶堆 其中greater&lt;int&gt;和less&lt;int&gt;即为仿函数，其中greater的实现如下 12345678template &lt;class T&gt;struct greater : public binary_function&lt;T, T, bool&gt;{ bool operator()(const T &amp;x, const T &amp;y) const { return x &gt; y; }} 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;//小顶堆int main(){ priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; que; que.push(7); que.push(5); que.push(-2); que.push(1); que.push(6); cout &lt;&lt; que.size() &lt;&lt; endl; while (!que.empty()) { cout &lt;&lt; que.top() &lt;&lt; &quot; &quot;; que.pop(); } cout &lt;&lt; endl; return 0;} 定义一个自定义类型的优先队列 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct node{ int x, y; //重载运算符，重载小于号，若需小根堆，this-&gt;x &gt; b.x 即可 bool operator&lt;(const node &amp;b) const { return this-&gt;x &lt; b.x; }};int main(){ priority_queue&lt;node&gt; que; que.push((node){1, 5}); que.push((node){2, 3}); que.push((node){9, 4}); que.push((node){-5, 5}); while (!que.empty()) { cout &lt;&lt; que.top().x &lt;&lt; endl; que.pop(); } return 0;} 12345[root@VM-12-16-centos lab]# ./a.out 921-5","link":"/2022/07/10/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"},{"title":"快速排序","text":"基于分治的思想，首先在数组中选择一个基准点，选取基准点的效率决定了时间复杂度，从数组两端扫描数组，设置low 和 high两个索引，图中蓝标代表low红标代表high，橘色表代表重合位置 首次分割，数列被分成了两个子数列，长度分别是i-1和n-i，排序时间表示为T(i-1)和T(n-i)，计算总时间还得加上分割操作的时间，分割操作只用了循环while(low&lt;high)，此段时间记为cn，所以Tn = T(i-1)+T(n-i)+cn； 演示1234567891011121314151617181920212223242526272829303132333435363738394041424344public class quicksort { public static void main(String[] args) { int[] arr = { 23, 46, 0, 8, 11, 18 }; quickSort(arr, 0, arr.length - 1); System.out.print(&quot;排序后 &quot;); for (int i : arr) { System.out.print(i+&quot; &quot;); } } private static void quickSort(int[] arr, int low, int high) { if (low &lt; high) { // 找寻基准数据的正确索引 int index = getIndex(arr, low, high); // 进行迭代对index之前和之后的数组进行相同的操作使整个数组变成有序 //quickSort(arr, 0, index - 1); 之前的版本，这种姿势有很大的性能问题，谢谢大家的建议 quickSort(arr, low, index - 1); quickSort(arr, index + 1, high); } } private static int getIndex(int[] arr, int low, int high) { // 基准数据 int tmp = arr[low]; while (low &lt; high) { // 当队尾的元素大于等于基准数据时,向前挪动high指针 while (low &lt; high &amp;&amp; arr[high] &gt;= tmp) { high--; } // 如果队尾元素小于tmp了,需要将其赋值给low arr[low] = arr[high]; // 当队首元素小于等于tmp时,向前挪动low指针 while (low &lt; high &amp;&amp; arr[low] &lt;= tmp) { low++; } // 当队首元素大于tmp时,需要将其赋值给high arr[high] = arr[low]; } // 跳出循环时low和high相等,此时的low或high就是tmp的正确索引位置 // 由原理部分可以很清楚的知道low位置的值并不是tmp,所以需要将tmp赋值给arr[low] arr[low] = tmp; return low; // 返回tmp的正确位置 }} 最坏的情况数列每次分割得到的两个子数列长度为n-1和0，也就是其中的每一个元素都要移动n次，总时间T(n^2) 123456789101112T(n) = T(n - 1) + C*n T(n - 1) = T(n - 2) + C*(n - 1) # 将 n 减 1，得到下个子序列T(n - 2) = T(n - 3) + C*(n - 3)....T(2) = T(1) + C*2T(1) = T(0) + C# 将下一级表达式代入上一级T(n) = T(0) + C*n + C*(n-1) + C*(n-2) + C*(n-3).....+C*(2)+C# T(0)是等于0的T(n) = C*n + C*(n-1) + C*(n-2) + C*(n-3).....+C*(2)+CT(n) = C*[n + (n-1) + (n-2) + (n-3).....+2+1]T(n) = C*(n + 1)*n/2 最高阶为$n^2$，最差时间复杂度为$O(n^2)$ 最好情况数列每次分割得到的两个子数列长度等长，除分割时间以外左右各为T(n/2)，总时间2T(n/2)+cn 12345678910T(n) = 2T(n / 2) + C*n T(n / 2) = 2T(n / 4) + C*n / 2 T(n / 4) = 2T(n / 8) + C*n / 4 ....# 将下一级表达式代入上一级，化简找到通项T(n) = 2^k*T（n/2^k）+ kcn# 当n/2^k-&gt;1， k = lg2nT(n) = nT(1) + cnlg2n 最优时间复杂度为O(nlgn) 平均时间复杂度 &lt;&lt;算法导论&gt;&gt; p98 p99","link":"/2021/10/01/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"title":"洛谷 P2820 局域网","text":"题目 某个局域网内有 $n(n \\le 100)$ 台计算机，由于搭建局域网时工作人员的疏忽，现在局域网内的连接形成了回路，我们知道如果局域网形成回路那么数据将不停的在回路内传输，造成网络卡的现象。因为连接计算机的网线本身不同，所以有一些连线不是很畅通，我们用 $f(i,j)$ 表示 $i,j$ 之间连接的畅通程度，$f(i,j)$ 值越小表示 $i,j$ 之间连接越通畅，$f(i,j)$ 为 $0$ 表示 $i,j$ 之间无网线连接。 需要解决回路问题，我们将除去一些连线，使得网络中没有回路，并且被除去网线的 $\\sum f(i,j)$ 最大，请求出这个最大值。 Input 第一行两个正整数 $n,k$。 接下来的 $k$ 行每行三个正整数 $i,j,m$ 表示 $i,j$ 两台计算机之间有网线联通，通畅程度为 $m$。 Output 一个正整数， $\\sum f(i,j)$ 的最大值。 Sample Input &amp; Output 12345675 51 2 81 3 11 5 32 4 53 4 28 并查集12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;struct ll{ int xx,yy,zz;//结构体分别存储边的两端点，长度}a[100001];bool cmp(ll x,ll y){ return x.zz&lt;y.zz;//sort排序设置边长为关键字}int n,m,s,n1,f[100001],l1,r1;int find(int a)//找父亲{ if(f[a]==a)return a; f[a]=find(f[a]); return f[a];}int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++) { cin&gt;&gt;a[i].xx&gt;&gt;a[i].yy&gt;&gt;a[i].zz; s=s+a[i].zz;//总长 } sort(a+1,a+1+m,cmp); for(int i=1;i&lt;=n;i++) f[i]=i;//赋初值 for(int i=1;i&lt;=m;i++) { l1=find(a[i].xx);r1=find(a[i].yy); if(l1!=r1)//如果没联通，则联通a[i].xx和a[i].yy的父亲节点 { f[l1]=r1; s-=a[i].zz;n1++; } if(n1==n-1)break;//n-1条就可以退出 } cout&lt;&lt;s; return 0;}","link":"/2022/07/19/%E6%B4%9B%E8%B0%B7-P2820-%E5%B1%80%E5%9F%9F%E7%BD%91/"},{"title":"栈","text":"简介和队列一样，栈stack也是一种线性序列结构，其存放的元素也是按照线性逻辑次序排列的，然而，与一般的线性结构相比，栈的操作仅限于逻辑上特定的一端，即新元素只能从栈的一端插入，也只能从这一端删除已有的元素。栈中允许元素插入和删除的一端称为栈顶，禁止操作的盲端称为栈底。于是，插入元素和删除元素就分别成为入栈和出栈。 12345678910111213141516171819202122232425262728293031//常规操作#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;cstdio&gt;using namespace std;stack&lt;int&gt; myStack;int main(){ printf(&quot;the size of myStack:%d\\n&quot;, myStack.size()); for (int i = 0; i &lt; 10; ++i) { myStack.push(i); } printf(&quot;the top of myStack:%d\\n&quot;, myStack.top()); printf(&quot;the size of myStack:%d\\n&quot;, myStack.size()); int sum = 0; while (!myStack.empty()) { sum += myStack.top(); myStack.pop(); } printf(&quot;sum:%d\\n&quot;, sum); if (myStack.empty()) { printf(&quot;myStack is empty&quot;); } return 0;} 12345the size of myStack:0the top of myStack:9the size of myStack:10sum:45myStack is empty 栈的应用逆序输出You are given a sequence of integer numbers. Zero-complexity transposition of the sequence is the reverse of this sequence. Your task is to write a program that prints zero-complexity transposition of the given sequence. 输入描述For each case, the first line of the input file contains one integer n-length of the sequence (0 ＜ n ≤ 10 000). The second line contains n integers numbers-a1, a2, …, an (-1 000 000 000 000 000 ≤ ai ≤ 1 000 000 000 000 000). 输出描述For each case, on the first line of the output file print the sequence in the reverse order. 输入 125-3 4 6 -8 9 输出 19 -8 6 4 -3 测试代码 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;cstdio&gt;using namespace std;stack&lt;long long&gt; reverse;int main(){ int num; while (scanf(&quot;%d&quot;, &amp;num) != EOF) { while (num--) { long long number; scanf(&quot;%lld&quot;, &amp;number); reverse.push(number); } while (!reverse.empty()) { printf(&quot;%lld &quot;, reverse.top()); reverse.pop(); } printf(&quot;\\n&quot;); } return 0;} 1235-3 4 6 -8 99 -8 6 4 -3 括号匹配问题输出包括两行，第一行输出原始输入字符，第二行由$ ?和空格组成，$ ?分别代表与之对应的左括号和右括号无法匹配。 样例输入 1)(rttyy())sss)( 输出 12)(rttyy())sss)(? ?$ 测试代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;stack&lt;int&gt; brackets;int main(){ string str; while (cin &gt;&gt; str) { string answer(str.size(), ' '); //设定为输入空格个长度 for (int i = 0; i &lt; str.size(); ++i) { if (str[i] == '(') { brackets.push(i); //压入左括号的下标 } else if (str[i] == ')') { if (!brackets.empty()) { brackets.pop(); } else { answer[i] = '?'; //右括号不匹配 } } } while (!brackets.empty()) { answer[brackets.top()] = '$'; brackets.pop(); } cout &lt;&lt; str &lt;&lt; endl; cout &lt;&lt; answer &lt;&lt; endl; } return 0;} 123)(rttyy())sss)()(rttyy())sss)(? ?$ 简单计算器描述读入一个只包含 +, -, *, / 的非负整数计算表达式，计算该表达式的值。 输入描述测试输入包含若干测试用例，每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。没有非法表达式。当一行中只有0时输入结束，相应的结果不要输出。 输出描述对每个测试用例输出1行，即该表达式的值，精确到小数点后2位。 输入 1231 + 24 + 2 * 5 - 7 / 110 输出 123.0013.36 测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cctype&gt;using namespace std;stack&lt;char&gt; operation;stack&lt;double&gt; data;int Priority(char c){ if (c == '#') { return 0; } else if (c == '$') { return 1; } else if (c == '+' || c == '-') { return 2; } else { return 3; }}double getNumber(string str, int &amp;index){ double number = 0; while (isdigit(str[index])) { number = number * 10 + str[index] - '0'; index++; } return number;}double Calculate(double x, double y, char op){ double result = 0; if (op == '+') { result = x + y; } else if (op == '-') { result = x - y; } else if (op == '*') { result = x * y; } else if (op == '/') { result = x / y; } return result;}int main(){ string str; while (getline(cin, str)) { if (str == &quot;0&quot;) { break; } int index = 0; str += '$'; //字符串尾部添加$ operation.push('#'); //运算符栈底添加# while (index &lt; str.size()) { if (str[index] == ' ') { index++; } else if (isdigit(str[index])) { data.push(getNumber(str, index)); } else { if (Priority(operation.top()) &lt; Priority(str[index])) { operation.push(str[index]); index++; } else { double y = data.top(); data.pop(); double x = data.top(); data.pop(); data.push(Calculate(x, y, operation.top())); operation.pop(); } } } printf(&quot;%.2f\\n&quot;, data.top()); } return 0;} 123451 + 23.004 + 2 * 5 - 7 / 1113.360 堆栈的使用堆栈是一种基本的数据结构。堆栈具有两种基本操作方式，push 和 pop。其中 push一个值会将其压入栈顶，而 pop则会将栈顶的值弹出。现在我们就来验证一下堆栈的使用。 输入描述对于每组测试数据，第一行是一个正整数 n（0 &lt; n &lt;= 10000）。而后的 n 行，每行的第一个字符可能是'P'或者'O'或者'A'；如果是'P'，后面还会跟着一个整数，表示把这个数据压入堆栈；如果是'O'，表示将栈顶的值 pop出来，如果堆栈中没有元素时，忽略本次操作；如果是'A'，表示询问当前栈顶的值，如果当时栈为空，则输出'E'。堆栈开始为空。 输出描述对于每组测试数据，根据其中的命令字符来处理堆栈；并对所有的'A'操作，输出当时栈顶的值，每个占据一行，如果当时栈为空，则输出'E'。 样例输入 1234567893AP 5A4P 3P 6OA 输出 123E53 测试代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;stack&lt;int&gt; myStack;int main(){ int n; char type; int x; while (scanf(&quot;%d&quot;, &amp;n) != EOF) { if (n == 0) { break; } for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; type; if (type == 'A') { if (myStack.empty()) { cout &lt;&lt; &quot;E&quot; &lt;&lt; endl; } else { cout &lt;&lt; myStack.top() &lt;&lt; endl; } } else if (type == 'P') { cin &gt;&gt; x; myStack.push(x); } else if (type == 'O') { if (!myStack.empty()) { myStack.pop(); } } } } return 0;} 1234567891011123AEP 5A54P 3P 6OA3","link":"/2022/06/04/%E6%A0%88/"},{"title":"流密码与分组加密","text":"流密码 逐位加密信息，将明文消息分解为单个位，然后使用密钥位将其分别转换为密文。流密码一次加密一位数据，而不用等待数据块的形成，此过程的关键在于根据加密密钥和种子（随机数nonce）生成伪随机比特流，它们一起创建了一个密钥流（伪随机比特流），该密钥流再与纯文本逐位进行异或运算，生成密文。因为每个数字的加密都取决于密码引擎的当前状态，所以流密码也被称为状态密码。 分组密码顾名思义，分块加密信息；分组密码将明文消息分解为固定大小的块block，然后使用密钥将其转换为密文。例如，当提供了一个x位分块纯文本（连同一个密钥）作为块密码引擎的输入时，它会生成相应的x位密文块，此过程依赖于密钥，同样解密算法利用x位分块密文和上述密钥作为输入，恢复原始的x位。每块使用相同的密钥（单独）加密，但是由于使用了相同的密钥，所以纯文本中的每个重复序列都转换成了密码本中相同的重复序列，可能会引起安全问题。流行的块密码是DES（数据加密标准）和AES（高级加密标准）。 对比流密码通常比分组密码执行得更快，当纯文本以不同数量可用时，比如一个安全的WIFI连接，流密码展现出比分组密码更大的优势，因为分组密码不能直接对小于块大小的块进行操作。但有时候，它们之间的差别不是很明显，这是因为当使用某些操作模式时，分组密码可以用作流密码，允许它加密可用的最小数据单元。 DES加密算法 该加密算法中，明文和密文为64位的文组文本，密钥长度也为64位，但是密钥的每组第8个位置设置为奇偶校验位，因而密钥实际长度为56位。 加密过程如下 初始置换 生成子密钥 迭代 逆置换 初始置换将原文本经过IP置换表处理 58,50,42,34,26,18,10,02,60,52,44,36,28,20,12,04,62,54,46,38,30,22,14,06,64,56,48,40,32,24,16,08,57,49,41,33,25,17,09,01,59,51,43,35,27,19,11,03,61,53,45,37,29,21,13,05,63,55,47,39,31,23,15,07, 例如如下64位的明文M 12345M = 0110001101101111011011010111000001110101011101000110010101110010---M' = 1111111110111000011101100101011100000000111111110000011010000011L0 = 11111111101110000111011001010111R0 = 00000000111111110000011010000011 在初始排列之后，我们有两个 32 位纯文本区域，分别称为左纯文本 L0 和右纯文本 R0。 子密钥生成每次迭代过程的数据长度为48位，因此需要16个48位的子密钥来进行加密，生成子密钥的过程如下 PC-1表 去除校验位后，密钥第一轮置换，PC-1表8*7，密钥K经PC-1后变为56位数据K0。 57,49,41,33,25,17,0901,58,50,42,34,26,1810,02,59,51,43,35,2719,11,03,60,52,44,3663,55,47,39,31,23,1507,62,54,46,38,30,2214,06,61,53,45,37,2921,13,05,28,20,12,04 Shift表 某一轮左移位数 PC-2表 由于PC-2表为8*6的表，经PC-2置换后的数据为48位，置换后得到子密钥K1，PC-2表中去除了第9，18，22，25，35，38，43，54位。 14,17,11,24,01,05,03,28,15,06,21,10,23,19,12,04,26,08,16,07,27,20,13,02,41,52,31,37,47,55,30,40,51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32 例如 123456789101112131415161718192021222324252627282930K = 0001001100110100010101110111100110011011101111001101111111110001第一轮置换去除校验位，经过PC-1置换K0 = 11110000110011001010101011110101010101100110011110001111C0 = 1111000011001100101010101111D0 = 0101010101100110011110001111进行第一轮移位，左移1位C1 = 1110000110011001010101011111D1 = 1010101011001100111100011110CD_1 = 11100001100110010101010111111010101011001100111100011110 (56位)C1与D1合并，经过第一轮PC-2置换，去除了第9，18，22，25，35，38，43，54位K1 = 000110110000001011101111111111000111000001110010 (48位)第二轮置换进行第二轮移位，左移1位C2 = 1100001100110010101010111111D2 = 0101010110011001111000111101CD_2 = 11000011001100101010101111110101010110011001111000111101 (56位)C2与D2合并，经过第二轮PC-2置换，去除了第9，18，22，25，35，38，43，54位K2 = 011110011010111011011001110110111100100111100101C3（28位） = 0000110011001010101011111111D3（28位） = 0101011001100111100011110101K3（48位） = 010101011111110010001010010000101100111110011001C4（28位） = 0011001100101010101111111100D4（28位） = 0101100110011110001111010101K4（48位） = 011100101010110111010110110110110011010100011101以此类推 迭代设Li（32位）和Ri（32位）为第i次迭代结果的左半部分与右半部分，子密钥Ki为第i轮的48位加密密钥。定义运算规则： Li = Ri-1;Ri = Li ⊕ f(Ri-1, Ki); 扩展置换EDES加密共执行16轮迭代，每次迭代过程的数据长度48位，然而初始置换完后每一半的长度为32位，如何扩展成48位？只是因为32位R0被分为8个块，每个块4位，每个块首尾各添加1个位，即可满足要求。 32, 01, 02, 03, 04, 05, 04, 05, 06, 07, 08, 09, 08, 09, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17,16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 01 123456789101112131415161718192021# Expansion D-box Tableexp_d = [32, 1 , 2 , 3 , 4 , 5 , 4 , 5, 6 , 7 , 8 , 9 , 8 , 9 , 10, 11, 12, 13, 12, 13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1 ]# Permute function to rearrange the bitsdef permute(k, arr, n): permutation = &quot;&quot; for i in range(0, n): permutation = permutation + k[arr[i] - 1] return permutation for i in range(0, 16): # Expansion D-box: Expanding the 32 bits data into 48 bits right_expanded = permute(right, exp_d, 48) 例如 123R0 = 0000 0000 1111 1111 0000 0110 1000 0011---E(R0)^k1 = 100000 000001 011111 111110 100000 001101 010000 000110 S-BOX由8个不同的代替盒（S盒）完成。每个S盒有6位输入，4位输出。代替运算流程如下 若S-盒1的输入为110111，第一位与最后一位构成11，十进制值为3，则对应第3行，中间4位为1011对应的十进制值为11，则对应第11列。查找S-盒1表的值为14，则S-盒1的输出为1110。8个S盒将输入的48位数据输出为32位数据。 S-盒1 14,04,13,01,02,15,11,08,03,10,06,12,05,09,00,07,00,15,07,04,14,02,13,01,10,06,12,11,09,05,03,08,04,01,14,08,13,06,02,11,15,12,09,07,03,10,05,00,15,12,08,02,04,09,01,07,05,11,03,14,10,00,06,13, S-盒2 15,01,08,14,06,11,03,04,09,07,02,13,12,00,05,10,03,13,04,07,15,02,08,14,12,00,01,10,06,09,11,05,00,14,07,11,10,04,13,01,05,08,12,06,09,03,02,15,13,08,10,01,03,15,04,02,11,06,07,12,00,05,14,09, S-盒3 10,00,09,14,06,03,15,05,01,13,12,07,11,04,02,08,13,07,00,09,03,04,06,10,02,08,05,14,12,11,15,01,13,06,04,09,08,15,03,00,11,01,02,12,05,10,14,07,01,10,13,00,06,09,08,07,04,15,14,03,11,05,02,12, S-盒4 07,13,14,03,00,06,09,10,01,02,08,05,11,12,04,15,13,08,11,05,06,15,00,03,04,07,02,12,01,10,14,09,10,06,09,00,12,11,07,13,15,01,03,14,05,02,08,04,03,15,00,06,10,01,13,08,09,04,05,11,12,07,02,14, S-盒5 02,12,04,01,07,10,11,06,08,05,03,15,13,00,14,09,14,11,02,12,04,07,13,01,05,00,15,10,03,09,08,06,04,02,01,11,10,13,07,08,15,09,12,05,06,03,00,14,11,08,12,07,01,14,02,13,06,15,00,09,10,04,05,03, S-盒6 12,01,10,15,09,02,06,08,00,13,03,04,14,07,05,11,10,15,04,02,07,12,09,05,06,01,13,14,00,11,03,08,09,14,15,05,02,08,12,03,07,00,04,10,01,13,11,06,04,03,02,12,09,05,15,10,11,14,01,07,06,00,08,13, S-盒7 04,11,02,14,15,00,08,13,03,12,09,07,05,10,06,01,13,00,11,07,04,09,01,10,14,03,05,12,02,15,08,06,01,04,11,13,12,03,07,14,10,15,06,08,00,05,09,02,06,11,13,08,01,04,10,07,09,05,00,15,14,02,03,12, S-盒8 13,02,08,04,06,15,11,01,10,09,03,14,05,00,12,07,01,15,13,08,10,03,07,04,12,05,06,11,00,14,09,02,07,11,04,01,09,12,14,02,00,06,10,13,15,03,05,08,02,01,14,07,04,10,08,13,15,12,09,00,03,05,06,11, 例如 12E(R0)^k1 = 100000 000001 011111 111110 100000 001101 010000 000110 S(E(R0)^k1) = 1000 1011 1100 0100 0110 0010 1110 1010 P-BOX将S-盒替代的输出结果作为P-盒置换的输入。P-盒置换表如下： 16,07,20,21,29,12,28,17,01,15,23,26,05,18,31,10,02,08,24,14,32,27,03,09,19,13,30,06,22,11,04,25, 123456789101112131415161718192021将S盒输出10001011110001000110001011101010（32位）经过P盒置换，P-盒置换输出01001000101111110101010110000001令扩展置换E、S-盒替代、P盒置换的过程作为函数f。第一次迭代过程f(R0,K1)为：f(R0,K1) = 01001000101111110101010110000001计算L1（32位） = R0 = 00000000111111110000011010000011计算R1（32位） = L0 ^ f(R0,K1) 11111111101110000111011001010111 01001000101111110101010110000001= 10110111000001110010001111010110R1（32位） = 10110111000001110010001111010110。将L1与R1作为输入，继续执行迭代过程f。直至输出L16与R16。经过16次迭代后输出:L16（32位） = 00110000100001001101101100101000R16（32位） = 10110001011001010011000000011000 逆置换将初始置换进行16次的迭代，即进行16层的加密变换，得到L16和R16，将此作为输入块，进行逆置换得到最终的密文输出块。逆置换是初始置换的逆运算。从初始置换规则中可以看到，原始数据的第1位置换到了第40位，第2位置换到了第8位。则逆置换就是将第40位置换到第1位，第8位置换到第2位。以此类推，逆置换规则表如下 40,08,48,16,56,24,64,32,39,07,47,15,55,23,63,31,38,06,46,14,54,22,62,30,37,05,45,13,53,21,61,29,36,04,44,12,52,20,60,28,35,03,43,11,51,19,59,27,34,02,42,10,50,18,58 26,33,01,41,09,49,17,57,25, 将L16与R16构成64位数据，经过逆置换表输出密文为： 密文 0101100000001000001100000000101111001101110101100001100001101000","link":"/2022/07/21/%E6%B5%81%E5%AF%86%E7%A0%81%E4%B8%8E%E5%88%86%E7%BB%84%E5%8A%A0%E5%AF%86/"},{"title":"队列","text":"简介队列queue是一种线性的序列结构，其存放的元素按照线性的逻辑次序排列，但与一般的线性序列结构如数组或向量相比，队列的操作只限于逻辑上的两端，即新元素只能从队列的一段插入（入队），并且只能从队列的另一端删除已有的元素（出队）。允许队列插入的一端称为队尾，允许队列删除的一端称为队头。 1234567891011121314151617181920212223242526272829303132333435//常规操作#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;using namespace std;queue&lt;int&gt; myQueue;int main(){ printf(&quot;the size of myQueue:%d\\n&quot;, myQueue.size()); for (int i = 0; i &lt; 10; ++i) { myQueue.push(i);//队列元素的添加 } //访问队列中的元素，front(),back() printf(&quot;the front of myQueue:%d\\n&quot;, myQueue.front()); printf(&quot;the back of myQueue:%d\\n&quot;, myQueue.back()); //队列的状态，size(),empty() printf(&quot;the size of myQueue:%d\\n&quot;, myQueue.size()); int sum = 0; while (!myQueue.empty()) { sum += myQueue.front(); myQueue.pop();//队列元素的删除 } printf(&quot;sum:%d\\n&quot;, sum); if (myQueue.empty()) { printf(&quot;myQueue is empty\\n&quot;); } printf(&quot;the size of myQueue:%d\\n&quot;, myQueue.size()); return 0;} 123456the size of myQueue:0the front of myQueue:0the back of myQueue:9the size of myQueue:10sum:45myQueue is emptythe size of myQueue:0 队列的应用约瑟夫问题（变体）n个小孩围成一圈，任意假定一个数m,从第p个小孩起按顺时针方向从1开始报数，当报到m时，该小孩离开然后继续从1开始报数。这样，小孩不断离开，圈子不断缩小直到所有小孩都从圈中出去。请按出去的先后顺序输出小孩的编号。输入n p m，输出小孩的编号序列，用空隔隔开。（用0 0 0结束循环） 样例输入 128 3 40 0 0 样例输出 16,2,7,4,3,5,1,8 测试代码 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;using namespace std;queue&lt;int&gt; children;int main(){ int n, p, m; while (scanf(&quot;%d%d%d&quot;, &amp;n, &amp;p, &amp;m)) { if (n == 0 &amp;&amp; p == 0 &amp;&amp; m == 0) { break; } for (int i = 1; i &lt;= n; ++i) { children.push(i); } for (int i = 1; i &lt; p; ++i) { children.push(children.front()); children.pop(); } while (!children.empty()) { for (int i = 1; i &lt; m; ++i) { children.push(children.front()); children.pop(); } printf(&quot;%d &quot;, children.front()); children.pop(); } printf(&quot;\\n&quot;); } return 0;} 猫狗收容所有家动物收容所只收留猫和狗，但有特殊的收养规则，收养人有两种收养方式：第一种为直接收养所有动物中最早进入收容所的。第二种为选择收养的动物类型(猫或狗)，并收养该种动物中最早进入收容所的。给定一个操作序列代表所有事件。若第一个元素为1，则代表有动物进入收容所。第二个元素为动物的编号，正数代表狗，负数代表猫;若第一个元素为2，则代表有人收养动物，第二个元素若为0，则采取第一种收养方式；若为1，则指定收养狗；若为-1则指定收养猫。请按顺序返回收养的序列。若出现不合法的操作，即没有可以符合领养要求的动物，则将这次领养操作忽略。 输入的第一行第一个数为操作次数n，接下来n行，每行有两个值m和t，分别代表题目中操作的两个元素。 样例输入 123456761 11 -12 01 2 2 -12 1 样例输出 1231 -1 2 测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;struct animal{ int number; //编号 int order; //次序 /*定义了一个与结构体同名的构造函数，因此可以按照构造函数的方法来定义结构animal 例如，animal(2,4)代表了一个动物，并且该动物的编号为2，次序为4*/ animal(int n, int o) : number(n), order(o) {} //构造函数};int main(){ queue&lt;animal&gt; cats; queue&lt;animal&gt; dogs; int n; int order = 0; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; ++i) { int method, type; scanf(&quot;%d%d&quot;, &amp;method, &amp;type); //入 if (method == 1) { if (type &gt; 0) { dogs.push(animal(type, order++)); } else { cats.push(animal(type, order++)); } } //出 else { //猫狗都有 if (type == 0 &amp;&amp; !dogs.empty() &amp;&amp; !cats.empty()) { //狗先 if (dogs.front().order &lt; cats.front().order) { printf(&quot;%d&quot;, dogs.front().number); dogs.pop(); } //猫先 else { printf(&quot;%d&quot;, cats.front().number); cats.pop(); } } //只有猫 else if (type == 0 &amp;&amp; dogs.empty() &amp;&amp; !cats.empty()) { printf(&quot;%d&quot;, cats.front().number); cats.pop(); } //只有狗 else if (type == 0 &amp;&amp; !dogs.empty() &amp;&amp; cats.empty()) { printf(&quot;%d&quot;, dogs.front().number); dogs.pop(); } //只要狗 else if (type == 1 &amp;&amp; !dogs.empty()) { printf(&quot;%d&quot;, dogs.front().number); dogs.pop(); } //只要猫 else if (type == 1 &amp;&amp; !cats.empty()) { printf(&quot;%d&quot;, cats.front().number); cats.pop(); } } } printf(&quot;\\n&quot;); return 0;}","link":"/2022/06/03/%E9%98%9F%E5%88%97/"},{"title":"2022.7.22","text":"核心词汇 conspiracy /kənˈspɪrəsi/ 密谋策划conceive 构想，怀孕perceive 感知deceive 欺骗decisive 决定性的conviction 信念convince 说服，使确信convenience 方便versatile 多才多艺的medium 中等的，媒介media 媒体（plural）thereby 从而sacrifice 牺牲strike 罢工，打击pre-emptive 先发制人evade 逃避strategic 战略上的religious 宗教的comprehensively 全面地comprehension 理解力，领悟能力serendipity /ˌserənˈdɪpəti/ 偶然cumulative 积累的，逐渐的swell 膨胀，增长，很愉快的dwell 居住，栖息ingenious 巧妙的indigenous 本土的methodical /məˈθɑdɪk/ 有条不紊的，井然有序的shrewd /ʃrud/ 精明的，敏锐的outrun 逃脱rivals 竞争对手confer 授予，协商conference 研讨会reference 参考coincide 符合，一致，同时发生coincidence 巧合phenomenon 现象，迹象，非凡的人phenomenally /fə’nɒmɪnəli/ 了不起的refrain 克制，避免excavations /ˌekskəˈveɪʃ/ 挖掘，开凿expenditure 开支excessive 过度的prohibitively 价格高到离谱的point out 指出prohibit 禁止exhibition 展览exposition 展览会exploration 探索，勘探exposure 暴露explode 爆炸 v.explosion 爆炸 n. 同义替换目的，意图 goal，target，intention，purpose计划，打算 scheme，strategy，design，plan，schedule复原 revert，recover，resume，renew积累 cumulative，accumulative，snowballing，swelling提出，指出 propound，point out，raise，propose，suggest开采，挖掘 excavation，dig，mining发掘 explore，discover，excavation 看看就好manhunt 搜捕meadows 草甸stadium 体育场馆venue 场地，地点revenue 收益，税收income 收入acoustics 声学，音响，音质purpose 意图，目的intention 打算，计划fabric 织物fabulous 极好的intriguing 有趣的impressive 印象深刻的imperative 强制的，紧迫的insulate 绝缘revert 还原，复原convert 转换invert 反转arena 竞技场depot 仓库incorporate 合并（incorporate into your life 并入你的生活）charismatic 有超凡魅力的resume 简历，复原fortress 要塞fortification 防御工事fort 堡垒，要塞strategic alliance 战略联盟religious conviction 宗教信仰decisive victory 决定性的胜利widespread conspiracy 广泛的阴谋comprehensively defeated 全面击溃affix 词缀hymn 圣歌organisms 机体，生物caissons 盒子dip 蘸，浸泡 阅读刷题计划总结题J17T1P2 Q18-22 Complete the summary below. Choose ONE WORD ONLY from the passage for each answer. It became a fortress with four towers after the fifth century, and was then transformed into a village containing more than 200 houses. was converted first into a 18._____ 答案：fortress J17T1P3 Q27-31 Complete the summary using the list of phrases, A-J, below. Write the correct letter, A-J, in boxes 27–31 on your answer sheet. After his father was executed by the Parliamentarians in 1649, the young Charles II sacrificed one of the very principles his father had died for and did a deal with the Scots, thereby accepting Presbyterianism* as the national religion in return for being crowned King of Scots. Charles II’s father was executed by the Parliamentarian forces in 1649. Charles II then formed a 27._____ with the Scots, and in order to become King of Scots, he abandoned an important 28._____ that was held by his father and had contributed to his father’s death. 答案：strategic alliance，religious conviction After being comprehensively defeated on the meadows outside the city by the Parliamentarian army, the 21-year-old king found himself the subject of a national manhunt, with a huge sum offered for his capture. The battle led to a 29._____ for the Parliamentarians and Charles had to flee for his life. 答案：decisive victory J17T2P3 Q37-40 Complete the summary using the list of words, A-G, below. Write the correct letter, A-G, in boxes 37-40 on your answer sheet. The solution to both these problems was the invention of the brilliantly simple yet phenomenally successful Post-It note. Such examples give lie to the claim that ingenious, designing minds are responsible for human creativity and invention. There is also often an element of 39._____ , for example, the coincidence of ideas that led to the invention of the Post-It note. 答案：luck（ingenious 巧妙，精妙，含运气成分） Just like Darwin’s Law of Natural Selection, the Law of Effect involves an entirely mechanical process of variation and selection, without any end objective in sight. There may be no clear 40._____ involved, but merely a process of variation and selection. 答案：goals（without any end objective in sight 看不到任何最终目标） J17T3P3 Q36-40 Complete the summary using the list of phrases, A-J, below. Write the correct letter, A-J, in boxes 36-40 on your answer sheet. He describes the use of caissons, which enable workers to dig down for considerable distances, often below the water table, until they reach bedrock. A particularly enjoyable part of the chapter was Barr’s account of how foundations are built. He describes not only how 39._____ are made possible by the use of caissons, … 答案：dip excavations（本人觉得此题迷惑性很强，great和considerable同义本没错，但是题目中问的是距离具体为长度而非深度，所以dip excavations更为准确，更深的挖掘） J17T4P2 Q19-22 Complete the summary below. Choose ONE WORD from the passage for each answer. J17T4P2 Q19-22 Complete the summary below. Choose ONE WORD ONLY from the passage for each answer. WELL DONE!","link":"/2022/07/22/2022-7-22/"},{"title":"SQL 查询优化器浅析 01","text":"大数据体系和SQL火山引擎例子来源：大规模机器学习平台架构设计 计算计算方面体现在高性能计算，需要考虑的因素 新硬件：CPU，GPU，多种类型网卡 虚拟化产生损耗：网络和容器会进行一定的虚拟化，存储的分层池化也会带来负载均衡的问题 繁多的分布式训练框架：由于机器学习平台的用户很多，并且不同任务依赖的分布式训练框架也不同（数据并行的框架，模型并行的框架，HPC框架，其他框架），不同训练框架有各自的调度和资源要求，给底层基础设施带来很多挑战 存储对于任何一个系统，存储都是必不可少的，而对于机器学习来说，面临的挑战也有很多 高性能和扩展性：随着硬件的计算性能越来越好，为满足读数据的高吞吐量，对于存储的要求非常高，比如需要面对达上百Gb/s的单租户带宽吞吐以及很小的延迟，存储的容量也是高达PB级别。为了提升模型训练的效率，需要数千个计算实例能同时访问的高性能共享存储。 易用性和安全性：对于用户而言，最重要的就是简单方便，能够传输通畅，数据上下云，部分数据对安全性也有要求，所以需要隔离存储；在使用框架的时候为了能够读写存储能够像读本地文件一样方便，就需要存储接口友好，代码零修改，兼容POSIX 成本：尽可能低的成本 调度基于高性能的硬件，调度首先需要对资源（计算+存储）进行池化，火山引擎机器学习平台有一个大的计算池，里面有大量的GPU和CPU，在保证不同用户计算容器间的隔离前提下，不同客户共享整个资源池，从而提高集群的利用率。 机器学习的调度需求比较复杂。比如一次分布式训练，有 Worker、Server 和 Scheduler 角色的实例。在调度时，它需要 Gang 调度的能力，所有实例（或其中某一种角色的实例）要么都起来，要么都不起来。同时在训练过程中还需要网络的亲和性。例如同一个分布式训练的容器，申请到的资源能在一台机器肯定是最好。申请多台机器时，这些机器之间的网络连接肯定是越近越好。所以在调度上我们有一些相应的调度策略，包括 多队列调度（排队、抢占）、Gang 调度、堆叠调度等。 应用分布式训练，加速方式主要从计算，通信，显存三个角度考虑 计算：因为训练一般都用GPU，火山引擎有一个高性能算子库，自主研发了很多中细粒度高性能算子，它们的性能往往较于好的开源实现有非常明显的提升 通信：火山开通了BytePS通信框架，同时利用了CPU和GPU两种异构资源来加速通信，在对拓扑的探测上做了细致的智能优化，并且支持异步和同步两种训练模式 显存：主要针对超大模型场景，开源了veGiantModel，支持混合并行的策略，包括数据并行，Tensor 并行和流水线并行；可根据参数量、计算量自动切分流水线。veGiantModel 的底层是基于 BytePS 做加速的。 批式计算和流式计算 流式计算 批式计算 特性 对数据流进行处理，实时计算 统一收集数据，存储到数据库中，然后对数据进行批量处理 时效性 实时计算，低延迟 非实时，高延迟 数据特征 数据一般是动态的，无边界的 数据一般是静态数据 应用场景 实时场景，时效性高，比如实时推荐，业务监控 时效性不用很高，离线计算，数据分析，离线报表 运行方式 流式计算的任务是持续进行的 批量计算一次性完成 这个就好比分组加密和流密码，分组加密就是批式计算，等着块生成了统一处理，而流密码则实时处理。 交互式分析引擎背景在开源大数据领域，交互式引擎是后来才出现的，最初，大数据领域数据处理引擎以MapReduce为主，但是MapReduce引擎采用了批处理设计理念，数据处理性能不行 IO密集型：Map阶段中间结果写磁盘，Reduce阶段写HDFS，多个MapReduce作业之间通过一个共享存储系统HDFS交换数据 任务调度和启动开销大：大量任务需要分布式调度到各个节点上，且每个任务需要启动一个Java虚拟机运行 无法充分利用内存：MapReduce是十多年前提出的分布式技术，当时内存的价格很高，所以设计理念是充分利用磁盘，而如今不再如此，新型计算引擎可以尝试通过内存加速 Map端和Reduce端均需要排序：这是其本身设计理念决定的，使得其无法很好地应对交互式处理场景 为了克服MapReduce地性能缺陷，Google提出了新型交互式计算引擎Dremel，它构建于Googel地GFS（Google File System）等系统之上，支撑了Google的数据分析服务BigQuery等诸多服务。Dremel的技术亮点主要有两个：一个是采用了MPP架构，使用了多层查询树，使得任务可以在数千个节点上并行窒息感和聚合结果；二是实现了嵌套数据的列式存储 ，避免读取不必要的数据，大大减少网络和磁盘IO。 分类交互式计算引擎是具备交互式分析能力的分布式大数据计算引擎，它常用于OLAP场景。OLAP有很多实现方法，根据存储数据的方式不同可以分为ROLAP，MOLAP，HOLAP等。 ROLAP：基于关系型数据库的OLAP实现（Relational OLAP）。它以关系型数据库为核心，以关系型结构进行多维度的表示和存储。它将多维结构划分为两类表：一类是事实表，用来存储数据和纬度关键字；另一类是纬度表，即对每个纬度至少使用一个表来存放纬度层次，成员类别等纬度描述信息。ROLAP的最大好处是可以实时的从源数据中获取最新数据更新，以保持数据实施性，缺点在于运算效率比较低，用户等待响应时间比较长。 MOLAD：基于多维度的OLAP实现（Multidimensional OLAP）。它以多位数据组织方式为核心，使用多纬数据存储数据。多维数组在存储系统中形成数据立方体（Cube）的结构，此结构是经过高度优化的，可以最大程度地提高查询能力。MOLAP的优势在于借助数据多纬预处理显著提高运算效率，主要额缺陷在于占用存储空间和数据更新有一定延滞。 HOLAP：基于混合组织的OLAP实现（Hybrid OLAP），用户可以根据自己的业务需求，选择哪些模型采用ROLAP，哪些采用MOLAP。一般来说，将不常用或需要灵活定位的分析使用ROLAP方式，而常用，常规模型采用MOLAP实现。 Impala和Presto可用于ROLAP场景，而Druid和Kylin常用于MOLAP场景。也有人将Druid规划到“HOLAP”范畴，因为它不会进行预计算，因此是一种“ROLAP”，但同时它此用了列式存储，且为非关系型模型，因此也是一种“MOLAP”。 常见开源实现在大数据生态圈中，主流的应用于ROLAP场景的交互式计算引擎包括Impala和Prosto，它们的特点如下： Hadoop native（跟Hadoop生态系统有完好的结合） 可直接在Hive Metastore对接，处理Hive中的表 可直接处理存储在HDFS和HBase中的数据 计算与存储分析：它们仅仅是查询引擎，不提供数据存储服务，所有要处理的数据都存储在第三方系统中，比如Hive，HDFS和HBase等 MPP架构：采用经典的MPP架构，具有较好的扩展性，能够对应TB甚至PB级别数据的交互式查询需求 嵌套式数据存储：支持常见的列式存储格式，比如ORC（仅Presto支持）和Parquet（Impala和Presto均支持） 主流的应用于MOLAP场景的交互式计算引擎包括Druid和Kylin，它们的特点如下： 数据建模：将数据分为纬度和度量两类，且所有查询必须针对以上两类列进行 数据预计算：为了提高数据查询效率，MOLAP引擎一般会根据纬度和度量列，预先生成计算结果 YARN 名词解释 Apache Yarn（Yet Another Resource Negotiator的缩写）是 hadoop 集群资源管理器系统，Yarn 从 hadoop 2 引入，最初是为了改善 MapReduce 的实现，但是它具有通用性，同样执行其他分布式计算模式。 职责 资源调度和任务管理 组件 RM（ResourceManger），NodeManager（NM），ApplicationMaster（AM），Container（容器） 背景既然说最初是为了改善MapReduce的实现，那么有何需要改善的？MapReduce1中，有如下局限性： 扩展性差：jobtracker 兼顾资源管理和作业控制跟踪功能跟踪任务，启动失败或迟缓的任务，记录任务的执行状态，维护计数器），压力大，成为系统的瓶颈 可靠性差：采用了 master/slave 结构，master 容易单点故障 资源利用率低：基于槽位的资源分配模型，槽位是一种粗粒度的资源划分单位，通常一个任务不会用完一个槽位的资源，hadoop1 分为 map slot 和 reduce slot，而它们之间资源不共享，造成一些资源空闲。 不支持多：不支持多种计算框架并行。 YARN 很好解决了 MapReduce1 中的局限性：yarn 基本思想：一个全局的资源管理器ResourceManager和与每个应用对应的ApplicationMaster，Resourcemanager 和 NodeManager 组成全新的通用系统，以分布式的方式管理应用程序。 组件ResourceManager 处理客户端请求 启动/监控ApplicationMaster 监控NodeManager 资源分配与调度 APPlicationMaster 程序切分 为应用程序申请资源，并分配任务 任务监控与容错 NodeManager 单个节点上资源管理 处理来自ResourceManager的命令 处理来自ApplicationMaster的命令 Container对任务运行环境的抽象，封装了CPU、内存等多维资源以及环境变量、启动命令等任务运行相关信息 Kuberneteskubernetes，简称K8s。是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes提供了应用部署，规划，更新，维护的一种机制。当部署完kubernetes，便拥有了一个完整的集群。 特点 可移植: 支持公有云，私有云，混合云，多重云（multi-cloud） 可扩展: 模块化，插件化，可挂载，可组合 自动化: 自动部署，自动重启，自动复制，自动伸缩/扩展 组件 一个kubernetes集群是由一组node机器组成，这些node上会运行由kubernetes所管理的容器化应用，每个集群至少有一个工作节点。 工作节点会托管所谓的 Pods，而 Pod 就是作为应用负载的组件。 控制平面管理集群中的工作节点和 Pods。 为集群提供故障转移和高可用性， 这些控制平面一般跨多主机运行，而集群也会跨多个节点运行。 关系代数就说一下join吧 例如，现在有一个任务让你查询某同学借阅的图书书名及作者，假设在数据库中有book表和borrow表，要查询图书的书名和作者在book表中，但是查找的人是这名同学，所以条件是借阅人为该同学，有关信息在borrow表中，因此待查询的对象为book表和borrow表，查询结果是部分属性列，我们想用选择和投影运算可以解决这个问题，可是这两个关系运算作用的对象应当为一个关系，为了解决这个问题，就可以用笛卡尔积使多个关系合并成一个关系；而连接运算就是在笛卡尔积运算的基础上进行某些选择的结果，根据定义，从两个关系的笛卡尔积中选取属性间满足一定条件的元组；大致分为 一般连接 等值连接 自然连接 一般连接假设两个关系R和S，A是R中的属性组，B是S中的属性组，这两个属性列数相同，而且取值是可以比较的。如果有需要计算R和S的一般连接，连接条件是C&lt;D，首先计算两个关系的笛卡尔积，R关系的每一个元组和S关系的每一个元组串接得到新关系5列20行，在此基础上进行筛选，提取2、3、4、8行即为最终结果。分析有以下要点： 两个关系参与 计算笛卡尔积 比较两个关系中的属性组 找出属性间值的比较符合条件的元组 等值连接等值连接运算从R和S的广义笛卡尔积中选择R关系在A属性组上的值等于S关系在B属性上值的元组，需要比较的通常是两个属性列是否相等，即θ为=。对于前面的例子，如果将条件改为C=D，也就是查询关系R的C上和关系S的D上元素相等的元组进行连接，发现其要点与一般连接不同的是需要选择属性组间值相等的元组。 在等值连接中有一种特殊情况，也可以比较两关系间某列相同元素的元组，比如 自然连接在上一个例子中，可以发现属性列值重复存储，这样没有意义，可以去掉重复的一列，保留一列B可以不用注明属性属于哪一个关系，连接运算符下面不用注明选择的条件，这种特殊情况的等值连接被称为自然连接，故给出定义，从R和S的广义笛卡尔积上选择R关系和S关系同名属性B上值相等的元组 等值连接 自然连接 保留重复的属性列 需要把重复的属性列去掉 从行的角度进行运算 同时从行和列的角度进行运算 相同的分量不一定能是相同的属性名 相同的分量要求必须是相同的属性名 外连接在自然连接中，有时候左右两边部分元组的属性无法匹配，合成后直接被删除了，我们将它们称为悬浮元组，而对于外连接来说，相当于对于自然连接的一种扩充，分为左、右、全外连接。自然连接中丢弃的悬浮元组在外连接中会根据左右情况予以保留。 例如学生表(左) 学号 姓名 班级 1 张三 1 2 李四 1 3 王五 2 成绩表(右) 学号 成绩 班级 1 90 1 2 100 1 左外连接 学号 姓名 成绩 班级 1 张三 90 1 2 李四 100 1 3 王五 NULL 2 右外连接 学号 姓名 成绩 班级 1 张三 90 1 2 李四 100 1 编译原理相关知识词法分析词法分析器在程序编译过程中所处的位置 Lexical Analyzer，输入源程序，扫描器Scanner从左至右逐个字符地对源程序进行扫描，产生多个单词符号；单词符号的种类有 基本字（关键字）：begin、repeat、for等程序语言定义好的 标识符：用来表示各种名字，如变量名、数组名和过程名 常数：各种类型的常数 运算符：+、-、*、/ 界符：,、;、()、space符 输出的单词符号的表示形式为(单词种别,单词自身的值)，单词种别通常用整数编码表示 若一个种别只有一个单词符号，则种别编码就代表该单词符号，假定基本字、运算符、界符都是一符一种。 若一个种别有多个单词符号，则对于每个单词符号，给出种别编码和自身的值 标识符单列一种，标识符自身的值表示成按机器字节划分的内部码。 常数按类型分种，常数的值则表示成标准的二进制形式 如何设计 扫描缓冲区两个指针分别指向起点和搜索位置，考虑到单词长度超过缓冲区的长度，造成存储不连续，可以分为两个半区互补使用。如果某单词的结尾在一个半区找不到，那么在下一个半区一定能找得到，所以半区的长度就是程序语言允许的单词最大长度，比如某编程语言的标识符长度不超过128，就可以推断出编译器的扫描缓冲区总长度为256。 状态转换图状态转换图是一张有限方向图，节点代表状态，用圆圈表示，状态之间用箭弧连接，上面的标记（字符）代表射出的结点状态下可能出现的输入字符或字符类，一张转换图只包含有限个状态，其中有一个为初态，至少有一个终态。状态转换图可用于识别一定的字符串，若存在一条从初态到某一终态的道路，且这条路上所有弧上的标记符连接成的字等于α，则称α被该状态转换图所识别。终态上的*代表最后一个输入的字符不属于刚才读入的单词，将其退回去。 几点限制，不必使用超前搜索 所有基本字都是保留字，用户不能用它们作自己的标识符 基本字作为特殊的标识符来处理，使用保留字表 如果基本字、标识符和常数（或括号）之间没有确定的运算符或界符作为间隔，则必须使用一个空白符作间隔 语法分析抽象语法树常见的查询优化器查询优化器的社区开源实践SQL相关的前沿趋势","link":"/2022/07/22/SQL%20%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E6%B5%85%E6%9E%90%2001/"}],"tags":[{"name":"核心词汇","slug":"核心词汇","link":"/tags/%E6%A0%B8%E5%BF%83%E8%AF%8D%E6%B1%87/"},{"name":"同义替换","slug":"同义替换","link":"/tags/%E5%90%8C%E4%B9%89%E6%9B%BF%E6%8D%A2/"},{"name":"看看就好","slug":"看看就好","link":"/tags/%E7%9C%8B%E7%9C%8B%E5%B0%B1%E5%A5%BD/"},{"name":"阅读刷题计划","slug":"阅读刷题计划","link":"/tags/%E9%98%85%E8%AF%BB%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/"},{"name":"口语准备计划","slug":"口语准备计划","link":"/tags/%E5%8F%A3%E8%AF%AD%E5%87%86%E5%A4%87%E8%AE%A1%E5%88%92/"},{"name":"写作登月计划","slug":"写作登月计划","link":"/tags/%E5%86%99%E4%BD%9C%E7%99%BB%E6%9C%88%E8%AE%A1%E5%88%92/"},{"name":"最小生成树","slug":"最小生成树","link":"/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"Kruskal","slug":"Kruskal","link":"/tags/Kruskal/"},{"name":"CPP","slug":"CPP","link":"/tags/CPP/"},{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"冒泡","slug":"冒泡","link":"/tags/%E5%86%92%E6%B3%A1/"},{"name":"排序算法","slug":"排序算法","link":"/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"递归求解","slug":"递归求解","link":"/tags/%E9%80%92%E5%BD%92%E6%B1%82%E8%A7%A3/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"树的遍历","slug":"树的遍历","link":"/tags/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"},{"name":"递归解法","slug":"递归解法","link":"/tags/%E9%80%92%E5%BD%92%E8%A7%A3%E6%B3%95/"},{"name":"深度优先","slug":"深度优先","link":"/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88/"},{"name":"非自顶向下","slug":"非自顶向下","link":"/tags/%E9%9D%9E%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B/"},{"name":"时间复杂度","slug":"时间复杂度","link":"/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"name":"完备的推理","slug":"完备的推理","link":"/tags/%E5%AE%8C%E5%A4%87%E7%9A%84%E6%8E%A8%E7%90%86/"},{"name":"暴力","slug":"暴力","link":"/tags/%E6%9A%B4%E5%8A%9B/"},{"name":"倍增优化DP","slug":"倍增优化DP","link":"/tags/%E5%80%8D%E5%A2%9E%E4%BC%98%E5%8C%96DP/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"指针","slug":"指针","link":"/tags/%E6%8C%87%E9%92%88/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"向量","slug":"向量","link":"/tags/%E5%90%91%E9%87%8F/"},{"name":"堆排序","slug":"堆排序","link":"/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"},{"name":"网格类问题","slug":"网格类问题","link":"/tags/%E7%BD%91%E6%A0%BC%E7%B1%BB%E9%97%AE%E9%A2%98/"},{"name":"插入排序","slug":"插入排序","link":"/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"},{"name":"希尔排序","slug":"希尔排序","link":"/tags/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"},{"name":"归并排序","slug":"归并排序","link":"/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"堆","slug":"堆","link":"/tags/%E5%A0%86/"},{"name":"优先队列","slug":"优先队列","link":"/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"快速排序","slug":"快速排序","link":"/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"对称加密","slug":"对称加密","link":"/tags/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"},{"name":"非对称加密","slug":"非对称加密","link":"/tags/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"},{"name":"分组密码","slug":"分组密码","link":"/tags/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/"},{"name":"流密码","slug":"流密码","link":"/tags/%E6%B5%81%E5%AF%86%E7%A0%81/"},{"name":"TLS三次握手","slug":"TLS三次握手","link":"/tags/TLS%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"},{"name":"队列","slug":"队列","link":"/tags/%E9%98%9F%E5%88%97/"},{"name":"青训营","slug":"青训营","link":"/tags/%E9%9D%92%E8%AE%AD%E8%90%A5/"},{"name":"课前笔记","slug":"课前笔记","link":"/tags/%E8%AF%BE%E5%89%8D%E7%AC%94%E8%AE%B0/"},{"name":"SQL optimizer","slug":"SQL-optimizer","link":"/tags/SQL-optimizer/"}],"categories":[{"name":"海国图志","slug":"海国图志","link":"/categories/%E6%B5%B7%E5%9B%BD%E5%9B%BE%E5%BF%97/"},{"name":"雅思分手计划","slug":"海国图志/雅思分手计划","link":"/categories/%E6%B5%B7%E5%9B%BD%E5%9B%BE%E5%BF%97/%E9%9B%85%E6%80%9D%E5%88%86%E6%89%8B%E8%AE%A1%E5%88%92/"},{"name":"盲人摸象","slug":"盲人摸象","link":"/categories/%E7%9B%B2%E4%BA%BA%E6%91%B8%E8%B1%A1/"},{"name":"数据结构","slug":"盲人摸象/数据结构","link":"/categories/%E7%9B%B2%E4%BA%BA%E6%91%B8%E8%B1%A1/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"通信协议","slug":"盲人摸象/通信协议","link":"/categories/%E7%9B%B2%E4%BA%BA%E6%91%B8%E8%B1%A1/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"},{"name":"大数据基础班","slug":"盲人摸象/大数据基础班","link":"/categories/%E7%9B%B2%E4%BA%BA%E6%91%B8%E8%B1%A1/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E7%8F%AD/"}]}